<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8">
<meta name="generator" content="pandoc">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">


<meta name="author" content="Yiran Sheng">

<meta name="date" content="2023-12-11">

<title>Write a Toy VPN in Rust</title>



<meta name="viewport" content="width=device-width,initial-scale=1">




























<!-- tabsets -->



<!-- code folding -->




<link href="style/main.css" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css"></head>

<body><div class="nav-back">
					 <a href="/">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 460.3 460.3"><path d="M230.149 120.939L65.986 256.274c0 .191-.048.472-.144.855-.094.38-.144.656-.144.852v137.041c0 4.948 1.809 9.236 5.426 12.847 3.616 3.613 7.898 5.431 12.847 5.431h109.63V303.664h73.097v109.64h109.629c4.948 0 9.236-1.814 12.847-5.435 3.617-3.607 5.432-7.898 5.432-12.847V257.981c0-.76-.104-1.334-.288-1.707L230.149 120.939z"/><path d="M457.122 225.438L394.6 173.476V56.989c0-2.663-.856-4.853-2.574-6.567-1.704-1.712-3.894-2.568-6.563-2.568h-54.816c-2.666 0-4.855.856-6.57 2.568-1.711 1.714-2.566 3.905-2.566 6.567v55.673l-69.662-58.245c-6.084-4.949-13.318-7.423-21.694-7.423-8.375 0-15.608 2.474-21.698 7.423L3.172 225.438c-1.903 1.52-2.946 3.566-3.14 6.136-.193 2.568.472 4.811 1.997 6.713l17.701 21.128c1.525 1.712 3.521 2.759 5.996 3.142 2.285.192 4.57-.476 6.855-1.998L230.149 95.817l197.57 164.741c1.526 1.328 3.521 1.991 5.996 1.991h.858c2.471-.376 4.463-1.43 5.996-3.138l17.703-21.125c1.522-1.906 2.189-4.145 1.991-6.716-.195-2.563-1.242-4.609-3.141-6.132z"/></svg>
          </a>
          <a href="https://github.com/yiransheng">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 35.318 35.318"><path d="M23.71 34.689c-.172.062-.345.137-.522.168-.678.121-1.112-.229-1.116-.922-.009-1.287-.009-2.572.012-3.859.022-1.48-.012-2.941-1.139-4.162.67-.12 1.266-.204 1.849-.338 3.862-.887 5.868-3.323 6.124-7.366.131-2.058-.236-3.946-1.604-5.567-.099-.114-.104-.373-.057-.539.364-1.34.258-2.649-.166-3.959-.105-.327-.279-.428-.602-.407-1.134.063-2.173.461-3.089 1.073-.883.593-1.705.722-2.754.482-2.31-.521-4.635-.369-6.94.165-.261.062-.612-.021-.851-.161-1.082-.634-2.164-1.25-3.412-1.496-.965-.188-1.049-.14-1.305.793-.322 1.176-.354 2.353-.025 3.536.047.172-.002.448-.117.575-2.557 2.853-1.631 8.244.092 10.309 1.34 1.604 3.12 2.326 5.096 2.701.345.064.688.113 1.033.173-.296.77-.562 1.497-.863 2.212-.059.138-.246.254-.399.312-1.938.752-3.604.199-4.713-1.56-.593-.938-1.354-1.639-2.488-1.842-.036-.007-.073-.026-.106-.021-.305.08-.607.164-.911.246.171.238.292.558.521.701.961.608 1.586 1.475 1.999 2.498.649 1.604 1.909 2.319 3.546 2.459.799.065 1.606.01 2.481.01 0 .996.036 2.133-.015 3.265-.026.61-.639.854-1.373.604-1.947-.666-3.752-1.621-5.311-2.963C.956 26.96-1.214 20.83.657 13.655 2.522 6.503 7.383 2.116 14.651.739 24.708-1.163 34.235 6.161 35.233 16.37c.788 8.048-3.949 15.579-11.523 18.319zm-9.481-8.839l-.016.038.055.009c.014.001.026.026-.039-.047zm-4.55 3.181c.157.097.307.22.477.273.062.02.177-.121.38-.271-.282-.107-.448-.201-.623-.225-.068-.008-.156.145-.234.223zm1.433.246c.023.105.232.236.355.234.119-.002.235-.16.354-.25-.108-.099-.216-.195-.548-.494-.072.208-.191.376-.161.51zm1.758-.423c-.148.035-.273.172-.408.266.079.1.158.193.285.35.175-.16.294-.271.414-.379-.1-.087-.217-.255-.291-.237zm-4.358-.593c.082.155.209.289.381.508.115-.188.24-.332.218-.361a1.931 1.931 0 0 0-.403-.367c-.01-.008-.213.186-.196.22z"/></svg>
					 </a>
				</div>


<div class="container-fluid main-container">




<div id="header">



<h1 class="title toc-ignore">Write a Toy VPN in Rust</h1>
<h4 class="author">Yiran Sheng</h4>
<h4 class="date">12/11/2023</h4>

</div>

<div id="TOC">
<ul>
<li><a href="#the-first-step" id="toc-the-first-step">The First Step</a>
<ul>
<li><a href="#preliminaries-environment-setup" id="toc-preliminaries-environment-setup">Preliminaries: Environment
Setup</a></li>
<li><a href="#proof-of-concept" id="toc-proof-of-concept">Proof of
Concept</a></li>
<li><a href="#the-way-packets-flow" id="toc-the-way-packets-flow">The
Way Packets Flow</a></li>
<li><a href="#basic-types" id="toc-basic-types">Basic Types</a></li>
<li><a href="#two-main-loops" id="toc-two-main-loops">Two main
loops</a></li>
<li><a href="#put-it-all-together" id="toc-put-it-all-together">Put it
All Together</a></li>
</ul></li>
<li><a href="#lets-epoll" id="toc-lets-epoll">Let’s Epoll</a>
<ul>
<li><a href="#quick-preview" id="toc-quick-preview">Quick
Preview</a></li>
<li><a href="#epoll-basics" id="toc-epoll-basics">Epoll Basics</a></li>
<li><a href="#understanding-epoll_event" id="toc-understanding-epoll_event">Understanding
<code>epoll_event</code></a></li>
<li><a href="#handling-callbacks-in-rust" id="toc-handling-callbacks-in-rust">Handling Callbacks in Rust</a></li>
<li><a href="#the-poll-wrapper" id="toc-the-poll-wrapper">The
<code>Poll</code> Wrapper</a></li>
<li><a href="#revised-device-type" id="toc-revised-device-type">Revised
<code>Device</code> Type</a></li>
<li><a href="#port-reuse" id="toc-port-reuse">Port Reuse</a></li>
<li><a href="#the-startup-and-the-handlers" id="toc-the-startup-and-the-handlers">The Startup and the
Handlers</a></li>
<li><a href="#thats-all-and-the-final-code" id="toc-thats-all-and-the-final-code">That’s all and the Final
Code</a></li>
</ul></li>
<li><a href="#many-peers" id="toc-many-peers">Many Peers</a>
<ul>
<li><a href="#project-overview" id="toc-project-overview">Project
Overview</a></li>
<li><a href="#peer-identities" id="toc-peer-identities">Peer
Identities</a></li>
<li><a href="#the-dual-purposes-of-allowedips" id="toc-the-dual-purposes-of-allowedips">The Dual Purposes of
<code>AllowedIPs</code></a></li>
<li><a href="#peer-selection" id="toc-peer-selection"><code>Peer</code>
Selection</a></li>
</ul></li>
</ul>
</div>

<div id="the-first-step" class="section level2">
<h2>The First Step</h2>
<div id="preliminaries-environment-setup" class="section level3">
<h3>Preliminaries: Environment Setup</h3>
<p>Before we dive into the heart of our toy VPN application, let’s set
the stage. Picture this: you’ve got a shiny VPN application, but how do
you know it really works? Testing it in the wilds of the internet is
like learning to swim by jumping into the deep end – possible, but
probably not a great idea. So, we’re going to start by simulating a more
controlled environment.</p>
<p>First things first, we need to test our application as if it’s
running on two separate machines on the same Local Area Network (LAN).
Why two machines, you ask? Well, a VPN isn’t much of a party if it’s
just one lonely computer talking to itself. We need a pair to truly test
the communication capabilities. Now, unless you have spare computers
lying around like socks, setting up multiple machines can be a bit of a
headache. Enter Docker, our virtual savior. We’ll use Docker containers
to mimic separate machines. It’s like having a LAN party without needing
to invite over your neighbor’s computers.</p>
<p>Our setup unfolds as follows: the host machine will play the role of
a client, akin to a home computer sitting behind a NAT, initiating the
connection to a remote VPN server. This server, running on a public IP
address, will be simulated by a Docker container. This container will be
equipped with a static IP and an open port, eagerly awaiting VPN
traffic. To link these two, we’ll craft a Docker network bridge.</p>
<p>Let’s start by creating our network:</p>
<div class="highlight"><pre><span></span>docker network create wontun-test
</pre></div>
<p>To confirm its successful creation, we run:</p>
<div class="highlight"><pre><span></span>&gt; docker network ls



NETWORK ID     NAME          DRIVER    SCOPE

4155cab105dc   host          host      <span class="nb">local</span>

de1a447dc1c9   none          null      <span class="nb">local</span>

fe67417d0dec   wontun-test   bridge    <span class="nb">local</span>
</pre></div>
<p>A quick peek with the ip command reveals an interesting entry. Notice
the interface name <code>br-fe67417d0dec</code>, which aligns with the
network ID for wontun-test:</p>
<div class="highlight"><pre><span></span>&gt; ip addr show



<span class="m">5</span>: br-fe67417d0dec: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="m">1500</span> qdisc noqueue state DOWN group default

    link/ether <span class="m">02</span>:42:86:23:e4:15 brd ff:ff:ff:ff:ff:ff

    inet <span class="m">172</span>.18.0.1/16 brd <span class="m">172</span>.18.255.255 scope global br-fe67417d0dec

       valid_lft forever preferred_lft forever
</pre></div>
<p>Now if we run an image with the <code>--network=wontun-test</code>,
the container will be reachable from host at the IP address
<code>172.18.0.2</code> (the host machine will have the ip
<code>172.18.0.1</code>) We just need to package our server binary into
a docker image and run it connected to this network.</p>
<p>Here’s the Dockerfile I crafted. It’s based on Ubuntu 22.04,
mirroring the host operating system. This ensures that we can compile
once on the host and seamlessly use the binary inside the container.
We’ll install a few networking utilities (to be explained later), and
copy over the Rust release binary <code>wontun</code> and a shell script
<code>run_server.sh</code> into our image.</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span><span class="w"> </span><span class="s">ubuntu:22.04</span>



<span class="k">RUN</span><span class="w"> </span>apt update



<span class="k">RUN</span><span class="w"> </span>apt install -y iproute2 libcap2-bin netcat



<span class="k">COPY</span><span class="w"> </span>target/release/wontun /wontun 



<span class="k">COPY</span><span class="w"> </span>scripts/run_server.sh /run_server.sh



<span class="k">CMD</span><span class="w"> </span>bash run_server.sh
</pre></div>
</div>
<div id="proof-of-concept" class="section level3">
<h3>Proof of Concept</h3>
<p>In the proof of concept stage, we aim to achieve a few key
outcomes:</p>
<ul>
<li><p>A single binary <code>wontun</code> is produced that can run both
on the client and server (with different command line
arguments)</p></li>
<li><p>When both ends are running, a virtual network
<code>10.8.0.1/24</code> is established between the two hosts</p>
<ul>
<li>The client will have a private IP address <code>10.8.0.3</code></li>
<li>The server will have a private IP address <code>10.8.0.1</code></li>
<li>We can think of <code>172.18.0.1</code> and <code>172.18.0.2</code>
established previously as their public IP addresses</li>
</ul></li>
<li><p>The moment of truth will be using <code>netcat</code>. If we can
successfully run <code>nc -l 10.8.0.1 80</code> on the server and the
client can connect with <code>nc 10.8.0.1 80</code>, we’ll know we’re on
the right track. It’s like sending a hello across this newly formed
digital world.</p></li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># Terminal tab 1</span>

./scripts/run_client.sh



<span class="c1"># Terminal tab 2</span>

docker run --name wontun-remote <span class="se">\</span>

  --rm --network<span class="o">=</span>wontun-test --cap-add<span class="o">=</span>NET_ADMIN <span class="se">\</span>

  --device<span class="o">=</span>/dev/net/tun wontun-remote:latest

  

<span class="c1"># Terminal tab 3 (run netcat)</span>

docker <span class="nb">exec</span> -it wontun-remote /bin/bash

<span class="c1"># inside the container</span>

root@146887094cb9:/# nc -l <span class="m">10</span>.8.0.1



<span class="c1"># Terminal tab 4</span>

nc <span class="m">10</span>.8.0.1
</pre></div>
</div>
<div id="the-way-packets-flow" class="section level3">
<h3>The Way Packets Flow</h3>
<p>Now that we know what we are aiming for, here’s a diagram
illustrating how we can achieve it. This diagram only covers one half
the flow: sending data from client to server, reversing the arrows
yields the second half.</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDk2NS4zMzkwNjU1NTE3NTc4IDE0OTUuMjYwMjIzMzg4NjcxOSIgd2lkdGg9Ijk2NS4zMzkwNjU1NTE3NTc4IiBoZWlnaHQ9IjE0OTUuMjYwMjIzMzg4NjcxOSI+CiAgPCEtLSBzdmctc291cmNlOmV4Y2FsaWRyYXcgLS0+CiAgPCEtLSBwYXlsb2FkLXR5cGU6YXBwbGljYXRpb24vdm5kLmV4Y2FsaWRyYXcranNvbiAtLT48IS0tIHBheWxvYWQtdmVyc2lvbjoyIC0tPjwhLS0gcGF5bG9hZC1zdGFydCAtLT5leUoyWlhKemFXOXVJam9pTVNJc0ltVnVZMjlrYVc1bklqb2lZbk4wY21sdVp5SXNJbU52YlhCeVpYTnpaV1FpT25SeWRXVXNJbVZ1WTI5a1pXUWlPaUo0bk8xZGFWTWp4N0w5N2w5QnpQdnlib1RwVy92aWIxeG16TER2T3k5dVhIVXdNREV3WEhVd01EQXlYSFV3TURBMFhHS0VYSFV3TURBMGtsaHYrTCsva3kwazlhcHVRR0prWEhVd01ERmkyV0hQU0sxU0xabDVUbVpsWmYzM3Q2bXBiNTNuMitxM1A2YStWWjlPSy9YYVdhdnkrTzEzZXYraDJtclhtbHh5ZkNUQ3Y3ZWI5NjNUOE1uTFR1ZTIvY2UvL3ozNFJuRGF2T2wrcTFxdjNsUmNkVEF3TVdLZE5wNzdQL3g5YXVxLzRYL3hTZTJNdmp0emN0cG1lMmVHaXlYOWVIYXdWSnV2aTByNDFmQ2hYbWRhMWROT3BYRlJyMXgxTURBd1pUNTZ3dnZLaW9CcDVWeDFNREF4T2VkQ01tVjgvOU5uK2xUYVFFdkZyVGZPNnY1SGo3V3p6aVUrNWtaY2RUQXdNRGZHTzhPYzlGeDFNREF3WmM5Y2RUQXdNR1dldUt6V0xpNDdlRVNhd0Z4MDdseHlVOHBjZFRBd01HTHVyRkg5WjdxOStXT0s5ZDlwZDFyTjYrcHNzOTVzVVpmL2gxZnBuMEdIVHlxbjExeDFNREF4TjYzbWZlTnM4TXo1ZWZYVSs4RXo1N1Y2ZmJ2elhIVXdNREZqdG94Y2RUQXdNVG5HYkg1THRMLy8ybnVSZUQvdlcvakJpOHRHdFUwcndQdnZObThycDdWY2RUQXdNR1ZOWEhVd01ERXlaNE5jZFRBd01URlE3MjVjZFRBd01UZlB3c1g2ejZCUHJjcE5kWkZXcTNGZnIwZGNkVEF3TVdKdW5MMDJYSFV3TURGais2QmRyZExEU2x4MU1EQXhZbTJzc3JML3dVQ0NwSFBKZDllYWpWQ2FwT0JXTXVkdC80RmFlMXgxTURBd1pWTFVYSFJjZFRBd01XSTlyOVRiMWNHTVVseDFNREF4TjM0a0pTd3FaVEVoNmxTZk92MkppY2pnM3YzTTVwcGZhenovM0ZpWnZWeDFNREF4TU5mYmNtNzU3bHYvdVQ5Zi96U1lrZnZiczBxM1A5d3k3cDIwbkZrejZIRzkxcmhPemtxOWVYbzlYSFV3TURFNFF2anVuNzluYVVSMmIxSmNkVEF3TVdGY2RUQXdNVEZjZFRBd01XSk1xRnhtbW9tQVE2QWxrMEpjWWt4K1hGeGNkVEF3TVRtVVhHYTgwbHhjZTg5Y2RUQXdNRFZuWHFYMWdlbEF4VFNscjF4MU1EQXdOMkxFY3Q5cFZWeDFNREF4WWUzYlNseDFNREF3WXV2MnQ1UjlMcGlVUW1HK000UmZPSk1uL054eDZ5eVQzcjlEK21OY2RUQXdNV1Q1dUloY2RUQXdNR1VramlSY2NwTzd1REcxZ2FXc1JwZXMyZWhzMTE2bzY0TEYzdjFadWFuVmFZNWxySjJaZXUyQzV1RGJLVHBkYlgyTFRrU25YSFV3TURBMitPZy9jRk03TzZ2SHBLaGRSYWU3czlSLzkxeDFNREF4TkQ5VndidXR4VEpvMG16VkxtcU5TbjBuZjBUMFhIVXdNREV6WEhVd01EQmlQYkhuZ1Z4MU1EQXhPS0tvczF0cngycC9mNTdkbUsyVHp2UCs3Y25LNGZmUzBHV0ZYSEt3MkZ4MU1EQXhNRUh0dEkraVQxeDFNREF4TjdwNElMMWNkVEF3TVRVd24xeGNLUzFjZFRBd01EZlMyOU5XU0ZmZ2pQRFdNS3RjWXBzeTFOYTZnRngwSzJQWTlxVy9wZlJYUzgrVlhIVXdNREUyTmlxZ3IvcXJmZkxObnZwY2JzYUZkZDY1VDF4MU1EQXdOSytqL1UxNXZIczB2WC9TZWpnNmVsNWNYRGc1ZXZaY2RUQXdNVEh3K2oyNzJlNlgzYy85bS9ybFJtZnR4LzdLcFowL1BiNi9XYitNLzBydjl5dXRWdlB4bDRGaTlpaExnS0pjZFRBd01UTXVNRll3WEhVd01EQTNYY2xnaU5wY2RUQXdNRFZjYm1ESVBYYytVODFjZFRBd01UUmNkVEF3TVRqZ1hIVXdNREUzWENKK1hGeWpYSFV3TURBMFU0d3JYSFV3TURCbFc1U2hVVHoxWmsranJMVmVPVngxTURBeFpubGdjdkN3Yzk5Z2sxeDFNREF3WW9WY2RUQXdNRFhvbElUQytHQktvZUJjZFRBd01UQ0FpeXl0eUdYNlhIVXdNREF5UEZTQ3I3SXlaS2RyWEhVd01EQTJXdXBnWitIMDVMWnlNdHZjWmZ1clVqZE9saVpGWDlKMm9JdnpKcEJPYXNBNFU4SW5YR1pjZFRBd01UQjgxMEJEdmptWHdseDFNREF3TVhWR2JrSStTbHgxTURBeE4vcnFhMXgxTURBeE5Qcm56RUNHUjJOY2RUQXdNV1ZHaElMN3pjV2ZNMXgxTURBd04xeDFNREF3WWllclRYTndzN1I3ZFREYlhyb3FpNEpjZFRBd01EZTZNbU5jZFRBd01HYU92dC95czUzTnE0MzV3NTh2YXo4blhIVXdNREJpWEhVd01EQTFzMXgxTURBd01XNmdaajdYZ2twY2RUQXdNR1ZjZFRBd01UUEtXRngxTURBeE9VWXliQ29uVzhkY2RUQXdNV05RMmtDb3JWSmNYREVqNGpwbVRXQWcyRTdDSzF4MU1EQXhZcWVPUVQ5Y2RUQXdNREtQWDF4MU1EQXhaazVjZFRBd01UZDZYSFV3TURFMFV5dXJYSFV3TURGampKOWNkVEF3TVdXM1JvMVNPTjljZFRBd01HWjNOSHZWeG1ubHRuMWZSeWUreFQ1OFAxeDFNREF4TmlaUXIxeDFNREF3TUNDU3FKZlpvU1Q0WmVQdSt5RlJzRlJVb08vL00yMWNkVEF3TVRSUXdwZmhPMTExOVZ4MU1EQXhaRGsvZTh2YjdmV0w4L2JUajdyWjNyNnZUTGk2d3ZXMThHNjVobXB5eStPUWFMa2t3RFJNZTIxSllTZGNkVEF3TVRWY2RUQXdNVFBSYytWbExGZ3pVWmk0T3FOY2RUQXdNV0ZYcDkvUDEyNDJYSFV3TURGbUxsdjdtKzU2d1Z4MU1EQXhZNzFjZFRBd01XUzdYRnhVTWNhQlhkem1PdFRjUUVEZ05xankrcEE5NnNuV1hIVXdNREEzcjF4MU1EQXdNbHgxTURBd051elMwblJwWUZ4Y1hIVXdNREZtWEhVd01ERTBYSFV3TURCaVEwRzJYSFV3TURBM1lPUERMMjZEYkMzSWdpOWhvVngxTURBeE9IenNzajg1NkxVN3R6RzEzWXlIWEhVd01EQmlSMXh1WGx4MU1EQXdOYVk4WEhSZVdmMzVYSFV3TURBd2RuWFY1K3A2WDFiWFdsdGNkVEF3TUdMN1J6ZUh5NXRjZFRBd01EZmkrSXl2cDF4MU1EQXdNeTFkWEhVd01ERmxYSFV3TURGamsyS25XVngxTURBd01FbFdYbHgxTURBeE9lRjhpb1F4WEhVd01ERmlYSFV3TURFNHkybHZwMnZXVTlMSFhIVXdNREF5WjQxUmFNTG4yR0lsWEhVd01EQXlYSFV3TURCbVowbExwNVAyK2l0Y2RUQXdNRGFUVUtwY2RUQXdNREZTOU5aTXZMN3o1NkNiWFZYV1NpbzRvRngxTURBeE9aWlpYSFV3TURCbE1jekdLaW10ZUUra2MxeGNnWm5iWmkxY2RKaURQMDFjY21Rai9Fdi96Ly81UGZ2cFhIVXdNREZqY2FSWFdseDFNREF4TUZ4MU1EQXdONjJsVUxWZWFYZG1temMzdFZ4MU1EQXdaWWE1UVYxTVhIVXdNREJscDkycHREcmZhNDJ6V3VOY0l2bFp0WEdXODBuNHJWeDFNREF4T2RMRHkyb2xKVngxTURBd1l2aGU5TE9vNDVxdCtNTkR3Y05jZFRBd01UUmZYSFJjZFRBd01UVllMb1JMWEhVd01ERXhwVERFNm15Z21YRXl2c25SNTJEZWhYTXBwTXpkaGVkY2RUQXdNREZUUWpLalBTUkVhbHgxTURBeE1ZSEFMNzFjZFRBd01XWmNkVEF3TURhbXIxeHVMb2xVZUdhelZOeGNjbEZ4WmoyTXVWeDFNREF4WmF6STMwekY4MldQWHROcHNmdGNkVEF3TVdNdGo1anUxK3laTWx4MU1EQXhNZDJRdjV6ZTA5eE1YSFV3TURFellkUmNkVEF3TVdIallrSTdnQzZJWmVTeGk4b3RYSFJGcUpYZWdGbGNkVEF3TVdGdFJNK0MvVngxTURBeE9lL3Y2T3pMOENEYlVHSmNkVEF3TURFM3pWeDFNREF3WWx4MU1EQXhNa2FuWUhCZG5GaGNkVEF3TVRoY2RKcGNkVEF3TUROVHJaM3g4ZGhQbEZoSTQ1VjFYR2FLd0dRa0k2VnZZcHhjYnJoUlhIVXdNREV5N29iRkwwU0RSRjljZFRBd01UYW1oSVhoMWpranNWeHVLV3RjZFRBd01UTHlpenhjZFRBd01UTkRPOThnaG1hU3NseDFNREF4WkVaT1hDS3lSWTllS2FGY2RUQXdNV0tsZmNtelhDTERJMlJjZFRBd01URXJ3bHgxTURBd01zWmgvWjJIV2lucFhIVXdNREUwenpSY0l1RDBjRXBmL2RhMFhIVXdNREV4K1Z4MU1EQXdOUHBTS3VabTB2dU9mWnhjZFRBd01ETThTcVY0S1NyYnRXVzFwWlhPeFZxbmZXT1dYSFV3TURGbXY3ZGNkVEF3TUdadVRzM1M0dkdrS0haMmpGeDFNREF3TVZCY2RUQXdNVEJjWW8xeHdvWmNkVEF3TVdGYXJKaGNkVEF3TVRIbG1wdkFTeWNnaHQ1Y2RDVW1OdWdtaEtDUW0xeDFNREF4WW52VXZDL3FiNHE1M1ozVmJ2ZlA3bFo1WjI3NVpIMk9iZTZ2Ni8yeSsxRFYydGJ6eStKcSs3emEzSnU1NDF4MU1EQXdOMmU3UHpwN0k5dUhNdGJhd2JLT0taWmNkVEF3TURmU2thdG4zR3JQZkRtWGNkaHNUclNlS1NaY2RUQXdNRE9yNEZ4MU1EQXhZbHgxTURBeFlpM1N6bHgxTURBeE1OZVVoYWs1VUk5Wk9WWTlLNUc0MGt2VVpTeWtUcjgwbFBkVzZWeDFNREF4WS9UcVBhRzhlTGJEU0lONFhIVXdNREExMlBDMnZJdkk2bzlrNjhteTNOUlRYRzZ5SzIxY0lvRzVRdTFjWEQreUoyTEp6azMvbkd2OFdLaGNkVEF3TVdaczdWeDFNREF4WTdISjFrN0pXS0NkZ0VPVTNGeDFNREF3WWx4MU1EQXdaYjljZFRBd01HYXFYSFV3TURFMlhIVXdNREF3WEhVd01ERmxlWCszZUZKUlhIVXdNREV3Mm9wY2RUQXdNR1Z5S3laMDYybTdjdmZ3by9IajhVSHVUVmRjZFRBd01HWFBucDU5WStaZ1hIVXdNREF5NGNxa1kxd2lmYmhjZFRBd01US2FYQ0xaekpiUFRzcGNkVEF3TVdYMVpDdUU0VngxTURBd01UTmNadlJQaHFGTW4xQmNZbTljZFRBd01ESmNkVEF3TURXL1cvWlVabXhjYnZHbTNGeDB4WVMyV3JOZm1qcnh1WWgxVmx4MU1EQXhaSGZxUklFNVQxeDFNREF3TWxkbWg4YU9YekkzbTVCN1hIVXdNREF4Y2tYeHJOTDZXdkZyKzdlYlhIVXdNREZpeTlQUDgvZWR2ZVhqL2VyOFkzM0M5VngxTURBeE5XNmM0NXBKUVlGTHAxeDFNREF3TnFwY2RUQXdNVEYrWEhVd01ERm1YRzVjZFRBd01XTW84R3h0ckZ4MU1EQXhNY2JyaVZ4MU1EQXdOVERCbEZ4MU1EQXhNbHgxTURBeE10K2NVRCtPdFk2bWZ5NDAyemRid3BxTlRzdGNZbFhkTE92SExhajU2cVc3VzluZTJybmUwWjNPOWZySnltbzVQMjVvdS9LZ2RiMnhWTm50WEZ5ZFBsMWNYUHg4ckxaZjJPN28vRU1uWENJdXdKaGNkVEF3TUREWDh0eGdJT2RTd2pWU3BWeDFNREF3WlU5Y1psdWx5VlpnVUV6S25iRE1lOE5TNTM2NGdOK21KTzJtWEhVd01ERTVMTWs0TmZoTjJWeDFNREF4WlZ4MU1EQXdaWnhjZFRBd01UZytMZVBqVnRmSlFkeXhwM3RjZFRBd01UVEF6NWpUUFhxYVhIVXdNREZoUHBXaHFWS1lYRnhWWEhVd01ERTF6Rkgwb3R5eGpLNnFuczVjWEZ4MU1EQXhadFlxZTF4MU1EQXdadnV0NThPMTlaV1h4OTNGdWVuM3FLcEt2RjlHVlZ4MU1EQXdOMnYrWEhVd01ERTJWVngxTURBd05mbUhzOGhjZFRBd01Ubm5Sbm5uVkh6ZmlUUHBYSFV3TURBekkxeDFNREF3TVlCU002NmRYSFV3TURGbFgxNnhVQ3BjZFRBd01EQ01YSFV3TURGaExxMTFYSFV3TURBd3pxd3RjaVhCWEhVd01EQml1S2M0Tm16aFFFMWZYSFV3TURFMTJHaXBuSStFM3NhYVdQTG1KSzYzNUZ4MU1EQXhPRWFtK1QxcFhIVXdNREV6SlRkU3l1NU14RDVjZFRBd01XTHAzdEcwWEhVd01EQm1LQzVjZFRBd01EZFB4MXgxTURBeE9OaGZQckRLOURLQjFvNnlLbHgxTURBeE5HQkVjS1ZjYnB0Y2RUQXdNVFB3OUp3MDBGeGNaam44UGx4MU1EQXhOZHZ0NWl4Z1dpdUhYSFV3TURBMWtaNDcyUHJDWEhVd01EQTJKYVRTTUNOY2NuQ01XOFZNdEQzb1hIVXdNREEyYlhwWjVTUW4xN0t3TmVCY2RUQXdNV1dUUUZ4MU1EQXhPR0djczdSY2RUQXdNVEZjZFRBd01URnRUVngxTURBd041eGNkVEF3TUdXUVNXM1FsTk9xdUhQYVhIVXdNREEwd3NCdDVkbzdyNVhXOGIxOVhIVXdNREUxZ0cxbzVpMmswSG5QV0hGY2RUQXdNRGZoS1Z4MU1EQXdZdTh0Smx4MU1EQXhZMzRxL3A5SVhIVXdNREUyVUlHaldTQ3YxRXZscFM1dVVGeDFNREF3TnBKY2RUQXdNVFpQWEc1Y2RGeDFNREF4WWVDRk1mRmNkVEF3TVRaY2RUQXdNRFdJWEhVd01EQXdYRnh1WEhVd01EQXhYSFV3TURGaXhKVlFzckJCeTZoYVhIVXdNREExaDlCb3AxeDFNREF4T0NZLzFseDFNREF4WmVVNlhIVXdNREU0eVMxY2RUQXdNV1E2TnZTVHhlMkJxb0RhdzYvaVhIVXdNREJsN3I5TnR1Y2dUelJnUm5GOXlWeDFNREF3WXR0ejhGeDFNREF3TnlRamFYSENTWmxjZFRBd01XTXQ1Q1RNdHpCWVlxdUx1K2RGWUlWY2RUQXdNVGVZWEhVd01ERTVkRngxTURBeE1sMVE4VngxTURBd05seHlxWStsWEhVd01EQTBYR0o0S0dBdnJyaEJYSFV3TURFellEeFdXTVpnYXIySmoxeDFNREF4Ti9yandjb2dOMHBjZFRBd01UTDhhVkhjSUZ4MU1EQXhPRngxTURBeE50Yk9lVnhpbVZKMmdDRGRYSFV3TURBMmRVQmJYSFV3TURBd1hIVXdNREUycTBXdHdiY3QwME90NGVSQlVUUzBtQ2RjZFRBd01XRjBYSFV3TURBeDNsYUFYR0tEWmlIM3hVTHRmU0NFOEVvcVhIVXdNREJpOVRlRCtFKzNRVngxTURBeE5YaXlQTVpjZFRBd01ESTZsREdtdUVIT1hGeGNkVEF3TURCNVlWeDFNREF3WldMdElkczZPV1JvcFZ4MU1EQXhObHhtdGtGY1lseDFNREF3TnVOUjNDQ0g0RHByc1NES1NJZjFpYlVvV1dDRTA5eGNkVEF3TVdKY2NsVnl3bHgxTURBeE56Y29aT0RoUjF4MU1EQXdZakpjZFRBd01HVllYSFV3TURFNFhIVXdNREZsYjg5Y2RUQXdNRFhTS0NoY2RUQXdNVEgrZGRiek11MkZnMXdpZG14aFdPUGRJelpjZFRBd01XWmFjVnhpTjF4MU1EQXdNNDBvMFZ4MU1EQXhZWmttNTJCY2RUQXdNREdWd01oY1hMdzlMVngxTURBd01waGNabGhvbzRpQm1XSXRnZUZjWmx4MU1EQXhPRngxTURBeE5GeDFNREF4TllaVmdWeDFNREF4WmpoY2RUQXdNVGxmWW8zeHdyakFyaktManNLMGxWaGNkVEF3TVRGY2RUQXdNRE83b0RrNnFlbEFyNHdybmx4MU1EQXhNVngxTURBd01WYllnSEhBbjhNdmwxeDFNREF4TUZ4MU1EQXhPVngxTURBeFpseDFNREF3TU1qSUo4SmNkVEF3TVRSY2JpM2pVbTB3dllKeHNtZGNicExqUzF4bW1XR1dNQ1JJWEhVd01ERmhOTTljZFRBd01HS3ZrMXh5d2x4eVpkeG9Mcnd6WmZSY2RUQXdNVGlHMENyQVhIVXdNREU0TEpTRVFzVFhYSFV3TURBMGRseDFNREF4WXlCbkxJRTBwWXRjZFRBd01UVmNkVEF3TVdKQ2NNcGNkVEF3TURBcllUVnhhTUtNdUMwME5yQk9NOXF1WjFxNlhIVXdNREV5bGx4MU1EQXhOYk5jZFRBd01ET3B3YmlCUVZ4MU1EQXdNRHZKNG90c2JjQmNkVEF3TURTaGt2RmNac0FsUzloY2RUQXdNRFZjZFRBd01XUmNkVEF3TUREclBQQmNkVEF3TURKK1hIVXdNREF3WEhVd01ERXdPZDVCWEhVd01EQTNROG05MTVUeXdUeWdxOWowZTFoY2RUQXdNRFZqZ2VGd2VhVk16Q0IramN5QllyUno2bUU3aXR2RFhIVXdNREEwa2pTelVLNmxpNCtYcGlOY2RUQXdNVFI1WEhVd01EQmxZSUpjZFRBd01Ua3NYSFV3TURGbHI0WEVPRWRreHBGZmJseDFNREF4TXVCY2RUQXdNR1dCa2tCY2RUQXdNVGtwWEhVd01ERmpQRngxTURBd01TV0srMXgxTURBd043SmNkVEF3TURCY2RUQXdNVFdHU1RCWVFzMHRUN1duWVdJZ21tUnBXRngwUTYxbFFHV1JtRngxTURBd04zUlR3bUt5ZzNCVlhHWmhYSFV3TURGa3BORFFRTXJ3TFVCY1ltdy9WcEJjZFRBd01USHN4bGRjZFRBd01EU2ZXazVjZFRBd01ERjUwQzFDK2VMMlpLRGdYSFV3TURCaVhIUmNZcHBjZFRBd01URkM4bmhjZFRBd01EZUIxVngxTURBeE5KdGNkVEF3TVRXZ21JcFlackZWb1BZd1hIVXdNREV5dkNqU3owQkprMXgxTURBeFpGUmNkVEF3TVRaY2RUQXdNVEtLTVRCOHFrdGNacGhrWEhVd01EQXlabHgxTURBeE9JMWNkVEF3TVdFalhHWjNpVngxTURBeE9aU0JobG5WdFB0SDRkWGlYSFV3TURGbFNseDFNREF4T1Z4MU1EQXdNSEEwMEZOY2RUQXdNVGxCWEhVd01ERTBNdDRnNTF4MU1EQXdNVngwWEhVd01ERXlURGpJVGluREtqRHBYSFV3TURFd1pZQzdwOHdycFZ4MU1EQXhNb3ZNTFlCY2RUQXdNR0tvSUlHSFhIVXdNREZsZHFoNFVZQ2RqTGhjZFRBd01XV3RJMU9RM3lUcG9peFE0Q0NzWEhVd01EQXlsazJXTUlWZ2ZVUzRNRDl3T1oxSjZKMndYSFV3TURBeHNKM2dYSFV3TURGa2VrSmNkVEF3TVRhMnFEMWNkVEF3TVRCY1pxT2c4akNFNERQR0p2dEhibHgxTURBd05LTWtPY0NoWnNXa1hIVXdNREZoWEhVd01EQXpobnRjZFRBd01ETkh3bWtoTFh4Y2RKdnFJTHhjZFRBd01ERllYQ0pPVWx4MU1EQXdNMGU1cUVIS0x2VmNkVEF3TVRpTU5lSGhmV05FYWx4MU1EQXdOdUV3WEhVd01ERTVjQ2U0MTQ3cFFrMVdYQ0l3NkZ4MU1EQXhZNEJjZFRBd01EUmdRWHd5c2Nid1cwQnlOSFJjZFRBd01EWHI1bHgxTURBd1l2dW5hTUJjZFRBd01UaGNkVEF3TVRZc1hIUllxVk04S1lWY1pseDFNREF3TTZaY2RUQXdNRFJuNEl4Y0l1WmYxQ0JjWmx4eU5jZ2d2K1J6SmNDWWFvUmNkVEF3TVRIS1FJM2d1VngxTURBd002eGNkVEF3TUdMSHExeDFNREF4TlNpckp2ZGNkVEF3TVRVOVhIVXdNREF3SVhkY2RFTkQ5VngxTURBd1prRGJYSFV3TURFMHFaRXVka28wSkZ4bVNtcmdlWUpZT1p2VVlyaGNkVEF3TVRGY2RUQXdNRFNDOEpsY2RUQXdNVG5JUXZINlhIVXdNREV5dXlBelhIVXdNREF5NXNaY2RUQXdNV09sWEhVd01ERXhKOXBUWEhVd01EQXhvN3BjY2x4dW1seDFNREF3WmM3Z1hHNWNkSndseWx4bW9seDFNREF3TjhwTXEydVQwMXgxTURBd041dGNkVEF3TURGY2RUQXdNVEJHYzFoY2RUQXdNVGxmd3BGMVdGeDFNREF3WlZ4bVhIVXdNREExWEhVd01ERTJYSFV3TURBMktFSmNkVEF3TURkdWtyUEg2VngxTURBeE1EbWFYSFV3TURBME56YkZadFZ6S2pwRlRJQ0Y4ZlpjZFRBd01EUmNkVEF3TUdWY2RUQXdNR0wwWEhVd01EQmxrbWRnZzRERnNuQzBYSFV3TURGbFhpK2FYSFV3TURBeEwxeDFNREF4TWx4MU1EQXhZV09OeXpLNlhIVXdNREJsTWFKOVk2MHhWRnM0VnRoMFJvWFRXTWpNalk2dnJWeHlWOTZTNmx4MU1EQXhNamN2TVZZc1hIVXdNREExcFVuQVhIVXdNREV6WEc3RFhIVXdNREV3Y2NFempsSTl3dW95WkU1ZG9XbnhsQ0ZwZ0hEUWMvTFk0b08xcEdkWVhIVXdNREEyVFZWY1ltQmNkVEF3TURKY2RUQXdNR0o3UjZKS1FtV1VYSFV3TURCaWc0dGNkRngxTURBeE5vMzJ3Tk5jWml4Y2RUQXdNVFZGeU9ESFhIVXdNREUydGx4MU1EQXdOMDNIVkZ2ak9IQmNkVEF3TVRFc0lERmNYRkJBZUhsS2NNcC9jY1dPWEhVd01EQXpXVndpV0Z4MU1EQXhORmhKV0NwSWwwaVFhSWFWaDh4eGlWeDFNREF4T2NTWWl6a2xwNzFKT2x4MU1EQXdNWWo1WEhVd01EQXg1Y0NTeEZ4MU1EQXhaRngxTURBeE1ialhzTWxjZFRBd01EQm1oY1ZjZFRBd01EZVBLVzdQWEhVd01EQTFJSlJjZFRBd01UQXVYSFV3TURFd1J0Q1loR1VtL3FEb1hHSmNkVEF3TVRlTVhIVXdNREZseFUxY2RUQXdNR0k5VGNoY2RUQXdNV01ta0lmVjJFZ3lkSHhjZFRBd01ES2xYSEpnbDdFZzBwTXJWMHpaWVBKY2RUQXdNRElxYjJNb2ZxTTFpRzI4UFZ4MU1EQXhOVngxTURBeE1Ea3dYSFV3TURFMDlITE9YSFV3TURFM2U4TGtKbkZ5ZzBnbVhIVXdNREU0dVNISjltQklTWEVsWEhVd01ERmt3V1NtVU4xZ1hIVXdNREF3WEhVd01EQXlJRngxTURBeE1heWFYSFV3TURFeHBIYzIwVUZLWEhVd01ERTQ5cEFvWURuNW5NWE5RY1FvdXRSY2NrazZYSFV3TURFM1gxL2hLRUJjY25iSVhIVXdNREUwVUVvN1ZVSmNkVEF3TURLaDhlUmNkVEF3TUdYQVhIVXdNREF5WEhVd01EQmk2VmhjZFRBd01ESTVYSFV3TURBME9MUWt4NXBLWEhSUTJLYkVpc0MzSm0xWFhIVXdNREZoMUZ4MU1EQXhZcTVYZ3IzWVhIVXdNREF3ZGx4MU1EQXdOVjQxdVNsY2RUQXdNVFJ2S05GRFhIVXdNREEyMzFTSEpkOWNkVEF3TVdPRjhOSXhRVVZlUDNFaFZrSkRYSFV3TURBd3J0cGNkVEF3TVdMeXFhbGNibHgxTURBd05FQXMyVngxTURBeFk2aGNkVEF3TVRKY1pvL2hYSFV3TURFd1FEallKV3hjWmpnb2xKMnlUVEhlU1BuYWJvTTZvSElwbmx4MU1EQXdORngxTURBd01OekxpVEkyMEhDeXdseDFNREF4WTF4MU1EQXdOajlTMmlsc1RyQ0FpamFFWEhVd01EQXlpdGJBWVZ4MU1EQXdZcHVqZ0NDR2liVzFSR3RjZFRBd01UTmNYRnhpVklqQjNJZDVXS0JFdGxCY2RUQXdNRFRoUnpyQUlmaGNkVEF3TUdYSVhIVXdNREV3dnBaY2RUQXdNVGd1ZkdSY2RUQXdNVFpDWEhVd01EQXh5RngxTURBeFlVUkhYSFV3TURFM1hIVXdNREJtWEhVd01ERTNNMXgxTURBd1pkVmNkVEF3TUREUFlWeDFNREF4WXpLVzhETEIxb2tna2Qrb1hIVXdNREF4YzhYaVhIVXdNREF5SjFncG1EaGNkVEF3TVRCVTRJNk5oeVVvT2x4MU1EQXdadGhjWW5kcFhIVXdNREEwZk5waVhIVXdNREEwY2JBZ1ZxT0RYSFV3TURCbDdpQndKTlpjZFRBd01XTm1YSFV3TURBeTdqdjFXM3Rha2tKemFtRXZJVngwMEhoY2RUQXdNRGFEcGVKclFiRm9YSFV3TURCbWxiRlVKVS9CV1NoY1hGeHVYSFV3TURBemg1ckRPSWRuWEhMdzM5alVrVngxTURBeFpTcXFTNFE1SUhBcEpwRThnS3BENkpsY2RUQXdNRFNUZ0xWTWRGeDFNREF3WmUrRFlvQmNkVEF3TUROYmNwNWNibHgxTURBeE40SmNYRUhQd2lDbGdjbGNkVEF3TVRJeFhIVXdNREUyNUNoOFJYRmNkVEF3TVRkY2RUQXdNR0pjZFRBd01EWnBpbGxjZFRBd01HTGNRT2dzckZ4dXZtQW9VbHgxTURBeFplOWNYRURoWkZ4MU1EQXhNVngxTURBeFpYTmkwTjVpcDF4eTdWeDFNREF4T1Z4dWcwQks0ZW96WEhVd01ERTVYSFV3TURBM2NscHpSalZCdmFVelY4Vm1YSFV3TURFNVRxWFZtR2RJS09SY2RUQXdNVFJmMXZIQndyeGNkVEF3TVdLcXQxeG1tMkpMY0RTQUxzRFdVcEJjWE1CRzZYamNJTFNIbmtNanBLYjRWakZKSTZWY2RUQXdNRFIvWEhVd01EQTFNYURncm8zemVVZGNkVEF3TVdKTTNtdnlyb2lCWEhVd01ERTBqaldBb0VPM0lmZVVYMlRqd1ZpcWYxeG1tVngxTURBeE0xeHVoazVjZFRBd01USm5LR291YjcvdXQrai9zMDg3THVsNWZYTnMxRlpqOGU3bXVHbWVwL2Y5ZmZxMFk3cGVKWTlFWEhVd01ERTNYOHQvWEdiKzN0dGNkVEF3TVREMmNEby9XSk15YzhQNW4zaHlrYkxlTWNjNjYzQzB5TTJBVUZBbWNsZkhkRGI2WGZ2aHZjU1ZYSFV3TURGaHBhVTBSbE9tdVY0OTcxeG15WERwTkcrajBsTmNYSll5Tm81a2hrdTY0MitveHZ4ajgrRDc1djNqc1Q2NFdKKytNdXRyVDBjck95WHJYSFV3TURFM3dESndyMEpHNkNqZ1hIVXdNREU1VTBEWVdyQmNkVEF3TVdWY2RUQXdNRFdEUnJCY2RUQXdNRENITWwyNlJGeDFNREF3TjF4MU1EQXhOUEhpZ0U1UEpXWWpwM3BjZFRBd01EWmNkVEF3TURlTWlYeGNkVEF3TVRCT2hHZVV2NDVjZFRBd01UZS9TVWxwbzF4MU1EQXhPZFRFWk9rb1Yvbm5pMldJbE5IcFhIVXdNREZsbVphK05WdXkvL1pvYzBSeUpZOWVYSFNaUzF4MU1EQXdNOWlncjZNNlhkeDUycWxkWEhVd01ERmpYSFV3TURGalZ1ejVjMXV0VnV6ZTdsSjdZRndpcG1Lbmk4R3hRT3RjY2xVNDU3UnhYSFV3TURGaFlaeXZ4NHRwSzVuWW81WHVsMXgxTURBeFpDOStQZXQwdnJaOXNMcjFmTFRadEdmWFMxeDFNREF4WWp1cVdybEtXNWRxdlY2N2JTY3F2VXZhMzF4MU1EQXdOTWVpU2x4MU1EQXhNblJjZFRBd01UZEo4cEpjZFRBd01USmNkVEF3TVRtUVArZTFZeXhlZWlDYXFVbUZhQ1RueVVPRmcxeDFNREF3TkRCbXFKYkZhNVhycjlKSWI3MnNYSFV3TURBMGpwbW5Zb1JjZFRBd01UbGNkVEF3TVRiRzU2Y3NYSFV3TURCaU9HeUN2Yy9BdkRNenZTYVdMMWVQOVBMdWpOdGhQOWJuTmx4MU1EQXdabHBiejJVenlKOHZOczgzVzNwbGRudkQzcXhjZFRBd01UajIvV1R6NVhSa1hIVXdNREU1NUNPcFhIVXdNREUyT0d5VUpmZ3p2Q2FLWEhVd01EQXh3R09INDh0Y1hEUXRNOVEyUzF4MU1EQXhNV3VsTkZ4MU1EQXdOVngxTURBd01GeDFNREF3TUZ4MU1EQXdaaWFsYkNCY2RUQXdNRFBaWEhVd01ERmg5bFh4L1kxY2RUQXdNVFhmWEhVd01EQTFVNEkya2pKVVN1YXFsTFdTb2xYanVseDFNREF3TU9WRHhIcDllMXgxTURBeE5KUjZQT1hlWEhVd01EQmlYSFV3TURBd0trbTFvME41VTdIM1hIVXdNREUwd2tYTy9seDFNREF3WmpiUDBuVnRLVngxTURBeE1zK05LWjh3dnJYNmZMKzV1WFp4dEZ0ZFczdTRiRlJjZFRBd01UWmNkVEF3TVRhY25GeDFNREF4TkVYSnFlUEpLRngxTURBeE00eGNkVEF3TURGY2RUQXdNVFBnVXJoVWpWeHl2RngxTURBeE5XQmNkVEF3TUdXa2xFbWdYSFV3TURGbXg5R085MXgxTURBeE00YWVaeXdseFlidGhGWjhQN2hiMTF4MU1EQXdaclhGbjA5Y2NzUDR3LzdKOGY3Rytjd25WTnBjZFRBd01UamE3a05sdmE1dW51ZG43bDUyMTF4MU1EQXhOcTdtMStkV1hIVXdNREJsM1Yrc2dzZXc2dFNVTjJQZlVzRWplNVVtVzR1MVhHTGdsNFM3d3B4elhIVXdNREZtWEhVd01EQm14MUVtZGlCQTFiMkdWMXgxTURBeE1zbkRYSFV3TURGaC9hbVBYSFV3TURFeVJLUlg0STliUVZ4MU1EQXhaZkkvcUlKSFhIVXdNREUwd0VaNktxdGNkVEF3TURCMzNseDFNREF3TXFUWlhHSStoUFVxZGJvMFA3K3kzdG00T0twZTdWN042NmZkWEdZdk0vZEdNYXBZU0N6SFhIVXdNREU0eW9pTG4xZVNPb1ByWEhVd01ERmhPc0poNFg0NjYzSk8zMXgxTURBd00xeDFNREF4WXI1SzQ3MUhlVngxTURBd05pZWRYSFV3TURBeG9vWm5YaVhHOCt1eHdQSjRxYmxRWEhVd01ERXp3SVNIaU96NTFaNDdYWGxlbldYN3pidjlwZnU3aS9PbDIvSmNJbXNoc2x4Y1V1NTA0aUNzVVpScHlGeDFNREF4Wkd5c2pWZVRYSFV3TURGbFhGemZLbHgxTURBd011NjVwY014WEhUQlhIVXdNREZqM045cXcxeDFNREF4WWw1Y2NxaFFvdjdzMS9XdFJWeDFNREF4WWlPYzR0MUtpNnlTanBGYWdGeDFNREF4T1hmZ2VXQ2o4WjljZFRBd01UaGNkVEF3TVRNeGg1M1c5WS9yeTRQMTZlM0huZDJucCtrdHhuNVo3RndpdXpjcGxVakhMaURFZ2ZWVVZsOTM3WEZjWENPMExxaWd6bHgxTURBeE5WeDFNREF4WkliNVhHNWRmTnhtY3lZcHZwOXBzOTFjZFRBd01UQitUTWxYUEhLY1k0S0NYSFV3TURFM2RIeDhydEtwWEZ4Z1NpWTNqRkZjZFRBd01EQW5XV2ZpMDROY2RUQXdNV0hkN1hVK2YxeDFNREF3TjFoNG81Z29WMXgxTURBeFpMdFdZbTlrWENKOUlTazluZkpVZENBdWZtbDAxMXgxTURBeE40SkpYQ0pjWXFhak9GeDFNREF3TkxESnMvbGNkVEF3TVdaY2RUQXdNRFBUMGR6VDNxZGhsbWs2OURlaFhIVXdNREExWjdacmE4M2w0NGVaeTltdEphZDNybzUyNTgxdTJiREQ4TDN2Mk85UGF0akJpZnhLYkZRMWsxTEN5NWNteko3TnlWWTFRMVhPcGJTOWFzcGNkRlV6UEx6RVRsQ21wamVENU5yUlhIVXdNREEzWEhVd01EQm1TMTFjZFRBd01ETmNkVEF3TVdaY2RQS3J6MXhpWEhVd01ERXlUazdrSWVQUzhKRmNkVEF3TURZZ1hHNWc0bHgxTURBeFpIZVlaMFB3WEhVd01ERXdYSFV3TURBMnUrRFd0dVRMZFgxMitXTFhORngxTURBd1pTOVhaL2V5N2x4MU1EQXdNc2x4NnFSUmdhQ2tYSFV3TURBelkrbGt0bzdUV0cxY2RUQXdNVFZjZFRBd01XUXdrcEpwWXpMcjlWeDFNREF3WXFucFBMQzJ2SHVQVUNSY2RUQXdNREd1TDRtRHN5RmZqSGFvWENMMXIrdlNvS2FDcGJkb1FpWE9MWTR1cU1xQVVmNWQ5L3k4WEhVd01ERXpYRzYvcnpUdVRuYlhadWUyMXV6T3kvVmNYSVB0N1RYK2RqdmMyYU1zNFNWS3VzN1VPTzZFdE9sY2RUQXdNV0xOdGVkRjZrVkhYSFV3TURBeXYzYTRSNkZVZEZxRVhIVXdNREJsWEhVd01EQTFaZWFPcHQ5Y2RUQXdNV1JjZFRBd01UQmNkVEF3TVdIYVBuRGFqdW55ckZ4MU1EQXdadm1KaldybnROS2h2R3hjZFRBd01UZXdnRSs1WEhTKzQ3eGNkVEF3TURDbmtsQTViR2h2eURSY2RUQXdNV1J1WW9abW1zSlA4VTR6NzF4MU1EQXhOVngxTURBeFpDV01SencxWEhVd01ERXhRTnBkVTRtNmdEM0ZsVEtBazJWY2NseDFNREF4Wkpqd1ZEeGxvSzdSZ0NmVDFudkpQVngxTURBeE1EUzYzLzZsMGFWZ2trNXY4dWlWOUpHa2xmVHROdjJMYkxDY2RNYTZqSWZ5V1Z4dVBkcEUwM3poNjM2Y2xMdEJneWxZWEhVd01ERmtXYkxwY1BXZjZtV1Jxdmgxd3BIekw5RmNkVEF3TVdLek9GT1Vla1JIWEc2OWxVNWNkVEF3TVRja20rYjFhWGhjZFRBd01XVk92MDljSXJCV3dxT2xtanZXMldoZGhtaUtMSldib2x4MU1EQXdNbHgxTURBd1pWU0N5enVlY1lYanA5Nmk0OUw1a1lQeXk1Yk9PVHBWUGpkZ2VhOTliVngxTURBd1pWOXVXbnBkckZ4MU1EQXhZNnpVNTU3djVseDFNREF4TmlmRnJPU1VoTlFzZ0gybTdJQ3M0cTNhYURyeWE1VGllREp5ZStiSWMxeDFNREF3TTZ6Tnhvb3NYSFV3TURBM3FYZk5KNVdSMDF4MU1EQXhNMXR4dVZ4MU1EQXdNbldaNDlYRzN2VDV3bnpsOG5INys2V28vb1B5YnB6UDVZdVNqclNxTjJoVzlseGNUclptWEhVd01ERTVYSFV3TURFejBLbHc5WHBjZFRBd01XUmhRckdjK0NURm9qS1VoZDVSankzUU1WNGxvK1ZXLy9iUnIxZGNkVEF3TUdVOVhjK20wU09OaEZ4MU1EQXhOVngxTURBd01FUmNkVEF3TUdXOXordmFoNk5peTJkKzVmSDZZT3U4ZGYrelZsbTVQbDF1L3poSzgvNk1mZDFFbWY1SUpjM0lKb2RjYmx4dXI3LzQ0dkJsT0h4NGpONjY5TTIyOGNsTW51aUUyYUd0ckVuY3UzMkVYdHczL3ZlMFhzTmNkVEF3TUdiK2ExeDFNREF4TlA3NHA1N3J6T3YrNlBacHRjMC9YSFV3TURBenFKMlVWTXVvTkhyZUxWU2UzT0pjWEl1OVBEYlB0My9VanBjdDI1aGNkVEF3TVRSVnlVWlBRWlVxNkhpcUlWeDFNREF3Tm01Y2RUQXdNVEloZDZwY2RUQXdNR0pjZFRBd01XWFE1VmJ3YkxWVzQ5dzgrbUJHWWYrOEo1N2hrVkt2ZjF4MU1EQXdOVnhjZlZ4MU1EQXhOK3RUNlhQbmZZL0t1YkEyU3FsRXF0NnBxWFcvdGlCYjArZGJkK2VMTDRkY2RUQXdNRGVMWEhVd01EQmkyMnF5SlZlRzVYMnBKb1BuWWRKcWd2bkIrVnh5cURReWxjUWdYMmVNKzU1bFhIVXdNREV3dUljeFhIVXdNREUwWENKZzlseDFNREF4TSs1Zm0xeDFNREF4WStiM2FzWGIxVngxTURBeE5seDFNREF3TlBWZk9aVHZMYmp5ZGx4MU1EQXdORW45OW9jNTNhSm82K2JjeS9QaVUrdjArZjc0MUt3OVhXK21PVjNPVGlkY2RUQXdNRFNUTXE0NWxiMnlWaVpvbmxDYWFyaGNkRVZsVnVOT1RVL21yT2hlWEhVd01EQXhMYWxjWXJpSTV2VDFoYzh3U1NYN29FbGhaYkt2ZzcxdlRXUFZWTDFjWE5uTU5OYjhXNkh4WEhVd01ERmtRL1A5NjluZ1hIVXdNREV3NlYxOW1sOWUyOXU1dlhwMlhIVXdNREUzYzdlemZ1MjRmcHR4WGlCalhIVXdNREJta2NYVFMwVEdkc1BYUHVHb1pGeDFNREF4TUt5TU02TjE1cVpDL24zSlhIVXdNREUyWEhVd01ERmhiN1hoNzBta1hIVXdNREZsdDBmUzVmTFVvRnhpZU9oci8rVzhrbUZEWEhVd01ERTRuV2RpUlA1Y2RGeDFNREF3WmtHRVhIVXdNREZqWkxtOGE5SnA3YnpNcjdSdU5xNlA1ci9YMXZqRGJ2Vmx3cS9jWEhVd01EQTE4bHgxTURBd05ZcUR1U21sNGpmTGQxMWNkVEF3TVROdXcwT3hWSHhheTJqTys2ajUzWWV3dHA5Y2RUQXdNVGhPMTlPWVNHR3h2MXgxTURBd011OWNkVEF3TVdLQ0lNTmNkVEF3TUdiQ1hIVXdNREJsMjh2V1dseDFNREF3TnRwUmRVN01sMWFKVTVLYWJrdWhVcEhXS2xoY2RUQXdNV0tUUG52R3RWeDFNREF3WlZ4MU1EQXhPTldsbEZad1hIVXdNREExc0hGY2RUQXdNVG5yWEhVd01EQXhYSFV3TURBeXhhVEN5a240WEhSTWZpVjl2VngwZDZpRUlJdWxra2FvajVhNWUzbUMwV2IyV0k0eFhIVXdNREU0aDVWK1hIVXdNREJtOEl4ME56dGY5dWcxblZ4MU1EQXhNcnRCZTc4bDJseDFNREF4Wk4xbTl2Qjc0NmVpMjhKMHgxT1lRRVJjZFBnMHBaR251dHZMUE9qdG96Q3FjOC83ZGRYZnVKczkvREJzckZOVStacUtManJGamVIZVI2dWI5bnFWNnNTSXF6UmNjdDljZFRBd01EWmNkVEF3TVdObXphdzFYSFV3TURFMFp2QmNkVEF3TUdWVUxaNDIxODIrcHZ0TFlPemc5OXM0U3ZYUkpTQ0E4NXBSdlZ4MU1EQXdOZW10eStETklGeDFNREF4WWRaY2RUQXdNVGpnaXRBaHZueVpzN2Vacys3VlhIVXdNREZqTHVXemhUOHE4NDlsWEhVd01ERTV5cFNrZkx1L3F6M0xYSFV3TURFM3Z2RFRwTmg5aGprcmJUa285WVpjZFRBd01XSzZYSFV3TURGbFhIVXdNREF3NXBaeWlGUzBzSG5mbm9HbFcyL2dSR2xKUld6VHBxU1VQVngxTURBeFlyNmpYSFV3TURFNDcxeDFNREF4TllOY2RUQXdNV1REaEZwY2NzdG1xRUN0VFhWTGhvZVhuYVVyWEhVd01ERXd1dEh1OFZtNHdraHkvbld0UnRMMVhIVXdNREF5dnRUVzF1dFc1ODdUN08zRDRmN0JaWFdodHJ6OCtIUFRxVngwUDZvbW5GeDFNREF3WWx4MU1EQXhOTU15UUlLOFNKMG5wNnU1aVA3VDVhaGNJcDQyUGZJOWtES0JrMzVjYmpHMFZYSXYva0VwWEhVd01EQTAzU2h1eFBGY2RUQXdNVGFmWEhVd01ERmlURngxTURBeFpmYjdYSFV3TURGbVB6b3o5Tzczb2pLMFZKcGVYRzY2WEhVd01ERTFNaTNBWEhVd01ERXl6aWxNdUlkcnBlTEhJSHVDeDRMdWZWeDFNREF4TjhxRVI4U3lKTkE0U29iVUtxbGNJbDljZFRBd01EU2tYR1pjZFRBd01ESFJjR1dWNGxsbmFLUmNkVEF3TVdHeWthZGNkVEF3TURXamExN0hrRngxTURBeFpEeGNkVEF3TVRuOEkxZnc2SlZjZFRBd01UQzV6eUJjZFRBd01XYkRiMWFQdXkwZ2hzeGNkVEF3TVRHMXQrSFZROUc4NWxlVXAxeDFNREF4WXJrNGtWeDFNREF3TUxySE9EcUdYMUNIVmx4MU1EQXhaYlN1TjVZcXU1MnIwNmVMaTUrUDFmWmNkVEF3TUdMYkxXVmVRUHpDbEZHblhISmR0TVZjZFRBd01UTmNkVEF3TVdWY2RUQXdNR1dqbTBWZGVGdERWbHgxTURBd05WcmlrTUJOeW5qajhkcENnNEp5dWNlMHY0eEx3cmhFNURiM1hIVXdNREJsOWY3K2xZRkxYSExia1ZrK0tOL3BvVXU1d2t2aHhtSnpKcUgwTmFSY2RUQXdNVEEwSzd6K0xMeGNJa3ZHZ2pqQ3hpTzV4YzNsaWppOVVzSTlTak9XZjNQOWgxeHlYSFV3TURGaitURmNkVEF3TUdWT2s5V2VPNCtCd1VhbnZhdTA4STNZYXAzc1h5L3N5YzNsWEhVd01ERm1sYXZLeWM3endzSDZVajF0dFVKK1hIVXdNREUxTTFwT3dTclJYSFV3TURCbHU2U0NRa21qWlVINTZhQnhMMXgxTURBd1puNWNkVEF3TVRCUDZkc3Q3MXgxTURBd01ueVgwWjJwZVRXaVhDTFhYSFV3TURFNGZWbXFxVngxTURBd1psZ3FwbHh5ZWNvc3kxTFozRzFPckN6SWdYN1hYSFV3TURBeDQxeDFNREF3TWtORmhWeDFNREF4TkNiQVVOSFJLYXJ3THNQTXZQaGNkVEF3TVdSaDRVM0FYSFV3TURFMmtwMG9jVC9FVHVXS2ROaWVYSFV3TURFNGFYUW4zeks5bitUUVowTnNSZnRoL2ZMUWJEemViczl1bmo5VnQ3azZYbDBwazlPQWFWeG1uRngxTURBeE1kNUNYSFV3TURBeWlhWmNjclNhdE1IVFhIVXdNREExalZ4MU1EQXhNZmNwYlN0R2NLbk9QODA2WkZ4MU1EQXhab3BjZFRBd01HV3pPcFhLUGtLWloxeDFNREF3TnNJN3g2QmNkVEF3TUROajRDdktSMnRRZkYyb2swNXMrTzNWU0h5cjNONXVkekI5ZmN2LzdhRldmZnllV2F5SlhseDFNREF3TlBxaFhIVXdNREZoazF4MU1EQXdORmREd1BqenR6Ly9YSFV3TURGbXJjUmNkVEF3TVRHOEluMD08IS0tIHBheWxvYWQtZW5kIC0tPgogIDxkZWZzPgogICAgPHN0eWxlIGNsYXNzPSJzdHlsZS1mb250cyI+CiAgICAgIEBmb250LWZhY2UgewogICAgICAgIGZvbnQtZmFtaWx5OiAiVmlyZ2lsIjsKICAgICAgICBzcmM6IHVybCgiaHR0cHM6Ly9leGNhbGlkcmF3LmNvbS9WaXJnaWwud29mZjIiKTsKICAgICAgfQogICAgICBAZm9udC1mYWNlIHsKICAgICAgICBmb250LWZhbWlseTogIkNhc2NhZGlhIjsKICAgICAgICBzcmM6IHVybCgiaHR0cHM6Ly9leGNhbGlkcmF3LmNvbS9DYXNjYWRpYS53b2ZmMiIpOwogICAgICB9CiAgICAgIEBmb250LWZhY2UgewogICAgICAgIGZvbnQtZmFtaWx5OiAiQXNzaXN0YW50IjsKICAgICAgICBzcmM6IHVybCgiaHR0cHM6Ly9leGNhbGlkcmF3LmNvbS9Bc3Npc3RhbnQtUmVndWxhci53b2ZmMiIpOwogICAgICB9CiAgICA8L3N0eWxlPgogICAgCiAgPC9kZWZzPgogIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSI5NjUuMzM5MDY1NTUxNzU3OCIgaGVpZ2h0PSIxNDk1LjI2MDIyMzM4ODY3MTkiIGZpbGw9IiNmZmZmZmYiPjwvcmVjdD48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxNi42NDM5NjY2NzQ4MDQ3IDIwMS45OTk5Mzg5NjQ4NDM3NSkgcm90YXRlKDAgODIuODQ5MzA0MTk5MjE4NzUgMTguNDEwOTgwMjI0NjA5Mzc1KSI+PHBhdGggZD0iTTEuNzUgMS43NyBMMTYzLjk3IC0xLjU0IEwxNjYuNzcgMzYuNTYgTDEuNCAzOC43NCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGw9IiNmZmVjOTkiPjwvcGF0aD48cGF0aCBkPSJNMCAwIEM1NC4xNyAxLjE4LCAxMTIuOTkgMC4yNCwgMTY1LjcgMCBNMCAwIEM0MC4wOCAtMC44NSwgNzkuNjYgLTAuNDEsIDE2NS43IDAgTTE2NS43IDAgQzE2NS42OSAxNS43MiwgMTY1Ljc2IDMwLjU4LCAxNjUuNyAzNi44MiBNMTY1LjcgMCBDMTY2LjA1IDE1LjIzLCAxNjUuNzkgMjguOTcsIDE2NS43IDM2LjgyIE0xNjUuNyAzNi44MiBDMTE1LjEzIDM2LjA5LCA2OC42MiAzOS43MSwgMCAzNi44MiBNMTY1LjcgMzYuODIgQzEyMy42NyAzNi42OSwgODMuMzYgMzYuODgsIDAgMzYuODIgTTAgMzYuODIgQy0wLjY3IDI1Ljc1LCAtMS4wMiAxOS42MywgMCAwIE0wIDM2LjgyIEMwLjQzIDI0Ljc1LCAxLjA1IDExLjg4LCAwIDAiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI0Ni43NTg4OTU4NzQwMjM0NCAyMDguNDEwOTE5MTg5NDUzMTIpIHJvdGF0ZSgwIDUyLjczNDM3NSAxMikiPjx0ZXh0IHg9IjUyLjczNDM3NSIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+SVAgUGFja2V0PC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ3MS43NjcxNjYxMzc2OTUzIDE5NS44NjMwMDY1OTE3OTY4OCkgcm90YXRlKDAgMTI0LjkzMTQ4ODAzNzEwOTM4IDM5LjAxMzY3MTg3NSkiPjxwYXRoIGQ9Ik0wIDAgQzY5LjMxIDAuNCwgMTQwLjM4IC0wLjM3LCAyNDkuODYgMCBNMCAwIEM4Mi40IDAuOTIsIDE2Mi43NiAwLjMzLCAyNDkuODYgMCBNMjQ5Ljg2IDAgQzI0OC4wMSAxNi44OCwgMjUwLjUxIDMxLjQxLCAyNDkuODYgNzguMDMgTTI0OS44NiAwIEMyNTAuNzIgMjEuMjYsIDI1MC4yNSA0My45OSwgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgNzguMDMgQzE4MS4yNCA3OS44NiwgMTEwLjM0IDc4LjMyLCAwIDc4LjAzIE0yNDkuODYgNzguMDMgQzE4My41NyA3OC4wOSwgMTE4LjA5IDc3LjE3LCAwIDc4LjAzIE0wIDc4LjAzIEMtMS4yNyA1NC4xOSwgMS41IDI5LjQ1LCAwIDAgTTAgNzguMDMgQy0xLjQ2IDU2LjYzLCAtMS4yNSAzNS41NiwgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NzMuMjYxMTU0MTc0ODA0NyAyMjIuODc2Njc4NDY2Nzk2ODgpIHJvdGF0ZSgwIDIzLjQzNzUgMTIpIj48dGV4dCB4PSIyMy40Mzc1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj50dW4wPC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ3MC45NzI1Nzk5NTYwNTQ3IDMxNC4wNTQ4NzA2MDU0Njg3NSkgcm90YXRlKDAgMTI0LjkzMTQ4ODAzNzEwOTM4IDM5LjAxMzY3MTg3NSkiPjxwYXRoIGQ9Ik0wIDAgQzg4LjAxIDAuNjMsIDE3Mi43MyAtMC4yNiwgMjQ5Ljg2IDAgTTAgMCBDNzkuMTcgLTAuOTMsIDE1OC4wMSAtMS43MiwgMjQ5Ljg2IDAgTTI0OS44NiAwIEMyNDcuOTEgMTkuMDMsIDI0OC4zNSAzNS44MSwgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgMCBDMjUwLjEgMzAuNDgsIDI1MC4xMSA1OC43NiwgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgNzguMDMgQzE5OC40NyA3OS4wOSwgMTQzLjg3IDc5LjI5LCAwIDc4LjAzIE0yNDkuODYgNzguMDMgQzE3OS4wOCA3Ni44MSwgMTA4LjQ5IDc2Ljc1LCAwIDc4LjAzIE0wIDc4LjAzIEMxLjIxIDU4LjcyLCAtMC4zNyAzNi40MSwgMCAwIE0wIDc4LjAzIEMtMS43IDU3LjE2LCAtMS40NyAzNi42NywgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MzEuNDUwOTQyOTkzMTY0MSAzNDEuMDY4NTQyNDgwNDY4NzUpIHJvdGF0ZSgwIDY0LjQ1MzEyNSAxMikiPjx0ZXh0IHg9IjY0LjQ1MzEyNSIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+ZW5jYXBzdWxhdGU8L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDcyLjMyODc4MTEyNzkyOTcgNDc3Ljg0OTM2NTIzNDM3NSkgcm90YXRlKDAgMTI0LjkzMTQ4ODAzNzEwOTM4IDM5LjAxMzY3MTg3NSkiPjxwYXRoIGQ9Ik0wIDAgQzUzLjQ4IDAuNTYsIDEwOSAwLjYzLCAyNDkuODYgMCBNMCAwIEM5Ni4wMiAwLjIxLCAxOTMuMDcgMS4yOSwgMjQ5Ljg2IDAgTTI0OS44NiAwIEMyNDcuOTQgMzAuNjEsIDI0OC4zMyA1OS4wNSwgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgMCBDMjUwLjgxIDIzLjI1LCAyNDkuMTkgNDguMjMsIDI0OS44NiA3OC4wMyBNMjQ5Ljg2IDc4LjAzIEMxOTIuMyA3Ny43OSwgMTM1LjUxIDc3LjYsIDAgNzguMDMgTTI0OS44NiA3OC4wMyBDMTY4LjU4IDc4LjA2LCA4OC4wOCA3OC40NiwgMCA3OC4wMyBNMCA3OC4wMyBDMC43NyA1NC4zNCwgLTAuOSAyNi44NSwgMCAwIE0wIDc4LjAzIEMtMC4yOCA1Mi4yNSwgLTAuNzEgMjYuODgsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTM4LjY2NjUxOTE2NTAzOTEgNTA0Ljg2MzAzNzEwOTM3NSkgcm90YXRlKDAgNTguNTkzNzUgMTIpIj48dGV4dCB4PSI1OC41OTM3NSIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+VURQIFNvY2tldDwvdGV4dD48L2c+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OTUuMzgzNTYwMTgwNjY0MSAyNzIuMTM2OTMyMzczMDQ2OSkgcm90YXRlKDAgMC40MzgzMjM5NzQ2MDkzNzUgMjEuNDc5NDc2OTI4NzEwOTM4KSI+PHBhdGggZD0iTS0wLjI1IDAuMiBDLTAuMDEgNy4yMywgMC43OSAzNS4yNywgMS4wNiA0Mi40NyBNMC42MiAtMC4xNyBDMC44NCA2Ljg5LCAwLjYyIDM1Ljc5LCAwLjcyIDQyLjkyIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OTUuMzgzNTYwMTgwNjY0MSAyNzIuMTM2OTMyMzczMDQ2OSkgcm90YXRlKDAgMC40MzgzMjM5NzQ2MDkzNzUgMjEuNDc5NDc2OTI4NzEwOTM4KSI+PHBhdGggZD0iTS02LjY3IDIyLjc1IEMtNC41NiAyNy43MywgLTQuMTEgMzIuODksIDAuNzIgNDIuOTIgTS02LjY3IDIyLjc1IEMtNC4xNyAzMC44NCwgLTEuMjggMzguMDgsIDAuNzIgNDIuOTIiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5NS4zODM1NjAxODA2NjQxIDI3Mi4xMzY5MzIzNzMwNDY5KSByb3RhdGUoMCAwLjQzODMyMzk3NDYwOTM3NSAyMS40Nzk0NzY5Mjg3MTA5MzgpIj48cGF0aCBkPSJNOC4wMiAyMi43MiBDNi43NyAyNy42NywgMy44NCAzMi44NCwgMC43MiA0Mi45MiBNOC4wMiAyMi43MiBDNC44MyAzMC43NywgMi4wMyAzOC4wMiwgMC43MiA0Mi45MiIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PC9nPjxtYXNrPjwvbWFzaz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2OS4zMDEzNDU4MjUxOTUzIDI1MS45NzI1OTUyMTQ4NDM3NSkgcm90YXRlKDAgMTQ5LjQ3OTQ2MTY2OTkyMTg4IC0wLjUyMTE1MzI5ODUwNjc2MDYpIj48cGF0aCBkPSJNMCAwIEM2NS4xMiAwLjU4LCAxMzAuODggLTAuNjcsIDI5OC45NiAtMS4wNCBNMCAwIEMxMDcuMDIgLTAuNjcsIDIxMi41OSAtMC44NCwgMjk4Ljk2IC0xLjA0IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjkuMzAxMzQ1ODI1MTk1MyAyNTEuOTcyNTk1MjE0ODQzNzUpIHJvdGF0ZSgwIDE0OS40Nzk0NjE2Njk5MjE4OCAtMC41MjExNTMyOTg1MDY3NjA2KSI+PHBhdGggZD0iTTI3NS40OSA3LjU2IEMyODAuODQgNS4yOCwgMjg3LjA4IDIuMDIsIDI5OC45NiAtMS4wNCBNMjc1LjQ5IDcuNTYgQzI4NC41OCAzLjYzLCAyOTEuNjggMC44NSwgMjk4Ljk2IC0xLjA0IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjkuMzAxMzQ1ODI1MTk1MyAyNTEuOTcyNTk1MjE0ODQzNzUpIHJvdGF0ZSgwIDE0OS40Nzk0NjE2Njk5MjE4OCAtMC41MjExNTMyOTg1MDY3NjA2KSI+PHBhdGggZD0iTTI3NS40NSAtOS41NCBDMjgwLjgzIC04LjExLCAyODcuMDggLTcuNjYsIDI5OC45NiAtMS4wNCBNMjc1LjQ1IC05LjU0IEMyODQuNTMgLTcuMzgsIDI5MS42NCAtNC4wNywgMjk4Ljk2IC0xLjA0IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48L2c+PG1hc2s+PC9tYXNrPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTk0LjUwOTg2NTQwMDMzNiAzOTUuNzUzNDE3OTY4NzUpIHJvdGF0ZSgwIDAuNDM2ODQ3MzkwMTY0MDE4NjMgNDIuMDgyMTgzODM3ODkwNjI1KSI+PHBhdGggZD0iTTAgMCBDMS43NiAzMy41MSwgLTEuNTMgNjIuMywgMC44NyA4NC4xNiBNMCAwIEMtMC4wMyAxOC4zNCwgMS42NSAzNC44MywgMC44NyA4NC4xNiIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTk0LjUwOTg2NTQwMDMzNiAzOTUuNzUzNDE3OTY4NzUpIHJvdGF0ZSgwIDAuNDM2ODQ3MzkwMTY0MDE4NjMgNDIuMDgyMTgzODM3ODkwNjI1KSI+PHBhdGggZD0iTS03LjU4IDYwLjY0IEMtMi42NCA3MS4wNywgLTMuMDMgNzYuNzIsIDAuODcgODQuMTYgTS03LjU4IDYwLjY0IEMtNi41MyA2Ni4yMSwgLTMuMjUgNjkuODYsIDAuODcgODQuMTYiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5NC41MDk4NjU0MDAzMzYgMzk1Ljc1MzQxNzk2ODc1KSByb3RhdGUoMCAwLjQzNjg0NzM5MDE2NDAxODYzIDQyLjA4MjE4MzgzNzg5MDYyNSkiPjxwYXRoIGQ9Ik05LjUyIDYwLjcxIEM3Ljk0IDcwLjk3LCAxLjAyIDc2LjYsIDAuODcgODQuMTYgTTkuNTIgNjAuNzEgQzYuOTUgNjYuMTQsIDYuNjIgNjkuNzgsIDAuODcgODQuMTYiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjwvZz48bWFzaz48L21hc2s+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0Ni44NDI1MTQwMzgwODU5NCAxMjgxLjQwNDAzNzQ3NTU4Nikgcm90YXRlKDAgMTI0LjkzMTQ4ODAzNzEwOTM4IDM5LjAxMzY3MTg3NSkiPjxwYXRoIGQ9Ik0wIDAgQzk3LjE5IC0yLjAyLCAxOTIuMzUgLTIuMywgMjQ5Ljg2IDAgTTAgMCBDOTguMjIgLTEuODYsIDE5NS42IC0xLjk4LCAyNDkuODYgMCBNMjQ5Ljg2IDAgQzI0OC4xMSAyNy41LCAyNDcuNDkgNTEuMTksIDI0OS44NiA3OC4wMyBNMjQ5Ljg2IDAgQzI1MC4xNCAyOC44NiwgMjQ5LjkxIDU2Ljg4LCAyNDkuODYgNzguMDMgTTI0OS44NiA3OC4wMyBDMTk4Ljk0IDgwLjg3LCAxNDguNjIgNzguMDUsIDAgNzguMDMgTTI0OS44NiA3OC4wMyBDMTYxLjc2IDc4LjYyLCA3Mi43NiA3OC4wMSwgMCA3OC4wMyBNMCA3OC4wMyBDLTAuNDcgNTEuOTMsIDIuMTUgMjUuOTIsIDAgMCBNMCA3OC4wMyBDMC42NSA1MS4zMSwgLTAuNzggMjMuNDgsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ4LjMzNjUwMjA3NTE5NTMgMTMwOC40MTc3MDkzNTA1ODYpIHJvdGF0ZSgwIDIzLjQzNzUgMTIpIj48dGV4dCB4PSIyMy40Mzc1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj50dW4wPC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ1LjE3MTIxODg3MjA3MDMxIDExMzMuOTUxOTE5NTU1NjY0KSByb3RhdGUoMCAxMjQuOTMxNDg4MDM3MTA5MzggMzkuMDEzNjcxODc1KSI+PHBhdGggZD0iTTAgMCBDNTkuMDIgMC45MSwgMTE2LjIyIDMuMTIsIDI0OS44NiAwIE0wIDAgQzYxLjYxIDAuNzcsIDEyMi4yMSAwLjk3LCAyNDkuODYgMCBNMjQ5Ljg2IDAgQzI1MC40MiAyNi45NywgMjQ3LjIxIDU3Ljg5LCAyNDkuODYgNzguMDMgTTI0OS44NiAwIEMyNDkuMjggMjguNjYsIDI1MS4wNyA1NS45NSwgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgNzguMDMgQzE1Ny4yMSA3NC41NywgNjMuMDUgNzcuNTQsIDAgNzguMDMgTTI0OS44NiA3OC4wMyBDMTY5LjI1IDc2LjMyLCA4OC43NyA3Ni41MywgMCA3OC4wMyBNMCA3OC4wMyBDMC4yOCA1Ni4yMSwgLTAuNDIgMzQuNzIsIDAgMCBNMCA3OC4wMyBDMS4xMiA1NC4yNCwgMS4zNSAyOS4xNywgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMDUuNjQ5NTgxOTA5MTc5NjkgMTE2MC45NjU1OTE0MzA2NjQpIHJvdGF0ZSgwIDY0LjQ1MzEyNSAxMikiPjx0ZXh0IHg9IjY0LjQ1MzEyNSIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+ZGVjYXBzdWxhdGU8L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDcuNDA0MDk4NTEwNzQyMTkgOTgzLjg4MzMxNjA0MDAzOTEpIHJvdGF0ZSgwIDEyNC45MzE0ODgwMzcxMDkzOCAzOS4wMTM2NzE4NzUpIj48cGF0aCBkPSJNMCAwIEM2MC45NyAtMC42NCwgMTIyLjU5IC0xLjA4LCAyNDkuODYgMCBNMCAwIEM1NS4zNCAwLjQzLCAxMDkuMTIgMS42NSwgMjQ5Ljg2IDAgTTI0OS44NiAwIEMyNTAuMzIgMTkuNjksIDI0OS44OCAzNS4zMywgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgMCBDMjUxLjIzIDI2LjQ3LCAyNDkuNSA1NC41NywgMjQ5Ljg2IDc4LjAzIE0yNDkuODYgNzguMDMgQzE5Ny4zNiA4MS4xOCwgMTQzLjI1IDgwLjQ2LCAwIDc4LjAzIE0yNDkuODYgNzguMDMgQzE5NS4yIDc3LjUyLCAxNDAuNTcgNzcuMjUsIDAgNzguMDMgTTAgNzguMDMgQzAuMTEgNTAuNTUsIC0xLjk2IDI2LjQ2LCAwIDAgTTAgNzguMDMgQy0wLjQ5IDUyLjUxLCAtMS4zMyAyNS44MywgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMTMuNzQxODM2NTQ3ODUxNTYgMTAxMC44OTY5ODc5MTUwMzkxKSByb3RhdGUoMCA1OC41OTM3NSAxMikiPjx0ZXh0IHg9IjU4LjU5Mzc1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj5VRFAgU29ja2V0PC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM2NS4xNzAwNzcyMDE2NDIgODA0LjEwNTUyMjc3ODkyOTMpIHJvdGF0ZSgwIC0yLjg5NjEyOTE4ODExNDc3IC01Ny43NjQxOTIyNjYwNjk4NykiPjxwYXRoIGQ9Ik0wIDAgQy0xLjUxIDEuMDksIC01LjU2IDQuODgsIC05LjA3IDYuNTYgQy0xMi41OCA4LjIzLCAtMTYuOCA5LjU0LCAtMjEuMDggMTAuMDYgQy0yNS4zNyAxMC41OCwgLTMwLjYgMTAuNSwgLTM0Ljc2IDkuNjggQy0zOC45MiA4Ljg2LCAtNDIuNDUgNy40MiwgLTQ2LjAzIDUuMTIgQy00OS42MiAyLjgyLCAtNTMuNzIgLTAuOCwgLTU2LjI2IC00LjEzIEMtNTguODEgLTcuNDcsIC02MC4xMSAtMTMuNTEsIC02MS4zIC0xNC44OSBDLTYyLjQ5IC0xNi4yNywgLTYxLjgxIC0xMy40MiwgLTYzLjQgLTEyLjQzIEMtNjQuOTggLTExLjQ0LCAtNjguMiAtOS41NiwgLTcwLjgyIC04Ljk2IEMtNzMuNDQgLTguMzUsIC03Ni4yNSAtOC4yOCwgLTc5LjEyIC04LjgxIEMtODEuOTkgLTkuMzQsIC04NS43NiAtMTAuOTMsIC04OC4wMyAtMTIuMTQgQy05MC4zIC0xMy4zNSwgLTkxLjM0IC0xNC40NCwgLTkyLjczIC0xNi4wNyBDLTk0LjEyIC0xNy43LCAtOTUuNjIgLTIwLjM5LCAtOTYuMzUgLTIxLjkzIEMtOTcuMDggLTIzLjQ3LCAtOTcuMDggLTI0LjIsIC05Ny4xMSAtMjUuMzIgQy05Ny4xNSAtMjYuNDQsIC05Ni4yIC0yOC43MSwgLTk2LjU1IC0yOC42NSBDLTk2LjkgLTI4LjU5LCAtOTcuMjIgLTI1LjU1LCAtOTkuMjIgLTI0Ljk4IEMtMTAxLjIyIC0yNC40MiwgLTEwNS4yNSAtMjQuMzIsIC0xMDguNTQgLTI1LjI2IEMtMTExLjg0IC0yNi4yLCAtMTE2LjQyIC0yOC40NSwgLTExOC45OSAtMzAuNjMgQy0xMjEuNTUgLTMyLjgxLCAtMTIyLjg4IC0zNS43MywgLTEyMy45MyAtMzguMzYgQy0xMjQuOTggLTQwLjk5LCAtMTI1LjIzIC00My45NywgLTEyNS4yNiAtNDYuNDEgQy0xMjUuMyAtNDguODQsIC0xMjUuMDEgLTUwLjk3LCAtMTI0LjE0IC01Mi45NiBDLTEyMy4yNiAtNTQuOTUsIC0xMjEuMzQgLTU2Ljc4LCAtMTIwLjAxIC01OC4zNCBDLTExOC42NyAtNTkuOTEsIC0xMTcuODIgLTYxLjIxLCAtMTE2LjEzIC02Mi4zNSBDLTExNC40MyAtNjMuNSwgLTExMi4wMyAtNjQuNjYsIC0xMDkuODQgLTY1LjIyIEMtMTA3LjY0IC02NS43OCwgLTEwNC43MiAtNjUuOTUsIC0xMDIuOTUgLTY1LjcxIEMtMTAxLjE3IC02NS40OCwgLTk5LjQyIC02My40OSwgLTk5LjE3IC02My44MyBDLTk4LjkzIC02NC4xOCwgLTEwMS4zMiAtNjUuNTksIC0xMDEuNDggLTY3Ljc5IEMtMTAxLjY0IC02OS45OCwgLTEwMS4wNSAtNzMuOTQsIC0xMDAuMTMgLTc3LjAzIEMtOTkuMjIgLTgwLjEyLCAtOTcuNzYgLTgzLjMyLCAtOTYgLTg2LjMyIEMtOTQuMjMgLTg5LjMyLCAtOTEuOTggLTkyLjczLCAtODkuNTUgLTk1LjAyIEMtODcuMTIgLTk3LjMyLCAtODQuMTggLTk4Ljg2LCAtODEuNDIgLTEwMC4wOCBDLTc4LjY2IC0xMDEuMywgLTc2LjI0IC0xMDEuOTMsIC03Mi45OSAtMTAyLjMzIEMtNjkuNzMgLTEwMi43NCwgLTY1LjA5IC0xMDIuODEsIC02MS44OCAtMTAyLjUyIEMtNTguNjcgLTEwMi4yMiwgLTU2LjI5IC0xMDEuNTUsIC01My43MyAtMTAwLjU2IEMtNTEuMTcgLTk5LjU3LCAtNDguMjIgLTk3LjkzLCAtNDYuNTEgLTk2LjU3IEMtNDQuOCAtOTUuMjEsIC00My45OCAtOTIuNDEsIC00My40OCAtOTIuNCBDLTQyLjk3IC05Mi4zOCwgLTQ0LjAzIC05NC42MSwgLTQzLjQ3IC05Ni40OCBDLTQyLjkgLTk4LjM1LCAtNDEuNzggLTEwMS4wNywgLTQwLjA4IC0xMDMuNTkgQy0zOC4zOCAtMTA2LjExLCAtMzUuNTQgLTEwOS4yMiwgLTMzLjI4IC0xMTEuNjEgQy0zMS4wMyAtMTE0LCAtMjkuMDggLTExNS45NSwgLTI2LjU0IC0xMTcuOTMgQy0yNCAtMTE5LjkyLCAtMjEuMDEgLTEyMS45NiwgLTE4LjA2IC0xMjMuNSBDLTE1LjExIC0xMjUuMDUsIC0xMi42NiAtMTI2LjE4LCAtOC44MiAtMTI3LjIxIEMtNC45OSAtMTI4LjI0LCAwLjQ0IC0xMjkuNTUsIDQuOTYgLTEyOS42NyBDOS40OSAtMTI5Ljc5LCAxMy45MiAtMTI4Ljk0LCAxOC4zMSAtMTI3Ljk1IEMyMi43IC0xMjYuOTcsIDI3LjIzIC0xMjUuNjgsIDMxLjI5IC0xMjMuNzQgQzM1LjM2IC0xMjEuNzksIDM5Ljg1IC0xMTguNDIsIDQyLjY5IC0xMTYuMjggQzQ1LjUyIC0xMTQuMTUsIDQ2LjUzIC0xMTIuODMsIDQ4LjMgLTExMC45NSBDNTAuMDcgLTEwOS4wOCwgNTIuMjYgLTEwNi45MiwgNTMuMyAtMTA1LjAzIEM1NC4zNCAtMTAzLjEzLCA1My44OSAtMTAwLjA3LCA1NC41NiAtOTkuNTkgQzU1LjIyIC05OS4xLCA1NS40OCAtMTAxLjM5LCA1Ny4yNyAtMTAyLjEzIEM1OS4wNiAtMTAyLjg3LCA2Mi4zNCAtMTAzLjg1LCA2NS4zIC0xMDQuMDQgQzY4LjI1IC0xMDQuMjMsIDcxLjk4IC0xMDQuMDgsIDc0Ljk5IC0xMDMuMjcgQzc4IC0xMDIuNDUsIDgwLjY2IC0xMDAuOTgsIDgzLjM2IC05OS4xNSBDODYuMDYgLTk3LjMyLCA4OS4yNyAtOTQuOTIsIDkxLjE4IC05Mi4yNyBDOTMuMDkgLTg5LjYxLCA5NC4wMSAtODUuNywgOTQuODEgLTgzLjIgQzk1LjYyIC04MC43LCA5NiAtNzkuNzIsIDk2LjAyIC03Ny4yNyBDOTYuMDQgLTc0LjgxLCA5NC43NiAtNjkuNTQsIDk0LjkxIC02OC40OSBDOTUuMDYgLTY3LjQ0LCA5NS43MSAtNzAuNjIsIDk2Ljk0IC03MC45NiBDOTguMTcgLTcxLjMsIDEwMC4wNSAtNzEuMTksIDEwMi4yOCAtNzAuNTMgQzEwNC41MSAtNjkuODgsIDEwNy45OCAtNjguNjYsIDExMC4zMyAtNjcuMDQgQzExMi42OCAtNjUuNDIsIDExNC44NiAtNjMuMzQsIDExNi4zOSAtNjAuODIgQzExNy45MSAtNTguMjksIDExOS4wOCAtNTQuNzksIDExOS40NyAtNTEuOSBDMTE5Ljg2IC00OS4wMSwgMTE5LjM5IC00NS43OSwgMTE4LjcgLTQzLjQ1IEMxMTguMDEgLTQxLjExLCAxMTYuMzkgLTM5LjMxLCAxMTUuMzMgLTM3Ljg1IEMxMTQuMjggLTM2LjM4LCAxMTMuNDEgLTM1LjIsIDExMi4zNyAtMzQuNjUgQzExMS4zMyAtMzQuMTEsIDEwOC44NiAtMzQuOTksIDEwOS4xMSAtMzQuNTkgQzEwOS4zNiAtMzQuMTksIDExMi41MyAtMzMuMjIsIDExMy44NSAtMzIuMjYgQzExNS4xOCAtMzEuMywgMTE2LjUxIC0zMC40MywgMTE3LjA3IC0yOC44MSBDMTE3LjY0IC0yNy4xOSwgMTE3LjczIC0yNC40NywgMTE3LjI1IC0yMi41MyBDMTE2Ljc3IC0yMC41OSwgMTE1LjM3IC0xOC40NSwgMTE0LjIgLTE3LjE3IEMxMTMuMDMgLTE1Ljg5LCAxMTEuNjYgLTE1LjI5LCAxMTAuMjMgLTE0Ljg0IEMxMDguNzkgLTE0LjM5LCAxMDcuMDMgLTE0LjM1LCAxMDUuNiAtMTQuNDUgQzEwNC4xNiAtMTQuNTQsIDEwMy4xMiAtMTQuMzksIDEwMS42MiAtMTUuNDEgQzEwMC4xMiAtMTYuNDQsIDk3LjIxIC0yMC40NywgOTYuNjEgLTIwLjYxIEM5Ni4wMSAtMjAuNzQsIDk4LjE2IC0xNy45NiwgOTguMDMgLTE2LjIxIEM5Ny45IC0xNC40NiwgOTYuNDUgLTExLjcyLCA5NS44NSAtMTAuMTEgQzk1LjI1IC04LjQ5LCA5NS40OSAtOC4zOSwgOTQuNDIgLTYuNTIgQzkzLjM1IC00LjY1LCA5MS4wNiAtMC45OCwgODkuNDQgMS4wOSBDODcuODIgMy4xNSwgODcuMzMgMy45OCwgODQuNjggNS44OCBDODIuMDIgNy43OCwgNzcuMTIgMTEuMTIsIDczLjQ5IDEyLjUgQzY5Ljg2IDEzLjg4LCA2Ni42MSAxNC4xMiwgNjIuOTEgMTQuMTQgQzU5LjIyIDE0LjE2LCA1NS4xMiAxMy41NywgNTEuMzEgMTIuNiBDNDcuNTEgMTEuNjQsIDQyLjk4IDEwLjI0LCA0MC4wOSA4LjM1IEMzNy4yIDYuNDYsIDM1LjA0IDEuODgsIDMzLjk2IDEuMjcgQzMyLjg5IDAuNjYsIDM0Ljg1IDMuNDIsIDMzLjY1IDQuNjcgQzMyLjQ1IDUuOTIsIDI5LjMzIDcuODYsIDI2Ljc2IDguNzggQzI0LjE5IDkuNzEsIDIwLjk5IDEwLjIzLCAxOC4yMyAxMC4yMyBDMTUuNDcgMTAuMjMsIDEyLjgzIDkuODEsIDEwLjE4IDguNzYgQzcuNTMgNy43MSwgNC4wNCA1LjQxLCAyLjM0IDMuOTUgQzAuNjQgMi40OSwgMC4zOSAwLjY2LCAwIDAgTTAgMCBDLTEuNTEgMS4wOSwgLTUuNTYgNC44OCwgLTkuMDcgNi41NiBDLTEyLjU4IDguMjMsIC0xNi44IDkuNTQsIC0yMS4wOCAxMC4wNiBDLTI1LjM3IDEwLjU4LCAtMzAuNiAxMC41LCAtMzQuNzYgOS42OCBDLTM4LjkyIDguODYsIC00Mi40NSA3LjQyLCAtNDYuMDMgNS4xMiBDLTQ5LjYyIDIuODIsIC01My43MiAtMC44LCAtNTYuMjYgLTQuMTMgQy01OC44MSAtNy40NywgLTYwLjExIC0xMy41MSwgLTYxLjMgLTE0Ljg5IEMtNjIuNDkgLTE2LjI3LCAtNjEuODEgLTEzLjQyLCAtNjMuNCAtMTIuNDMgQy02NC45OCAtMTEuNDQsIC02OC4yIC05LjU2LCAtNzAuODIgLTguOTYgQy03My40NCAtOC4zNSwgLTc2LjI1IC04LjI4LCAtNzkuMTIgLTguODEgQy04MS45OSAtOS4zNCwgLTg1Ljc2IC0xMC45MywgLTg4LjAzIC0xMi4xNCBDLTkwLjMgLTEzLjM1LCAtOTEuMzQgLTE0LjQ0LCAtOTIuNzMgLTE2LjA3IEMtOTQuMTIgLTE3LjcsIC05NS42MiAtMjAuMzksIC05Ni4zNSAtMjEuOTMgQy05Ny4wOCAtMjMuNDcsIC05Ny4wOCAtMjQuMiwgLTk3LjExIC0yNS4zMiBDLTk3LjE1IC0yNi40NCwgLTk2LjIgLTI4LjcxLCAtOTYuNTUgLTI4LjY1IEMtOTYuOSAtMjguNTksIC05Ny4yMiAtMjUuNTUsIC05OS4yMiAtMjQuOTggQy0xMDEuMjIgLTI0LjQyLCAtMTA1LjI1IC0yNC4zMiwgLTEwOC41NCAtMjUuMjYgQy0xMTEuODQgLTI2LjIsIC0xMTYuNDIgLTI4LjQ1LCAtMTE4Ljk5IC0zMC42MyBDLTEyMS41NSAtMzIuODEsIC0xMjIuODggLTM1LjczLCAtMTIzLjkzIC0zOC4zNiBDLTEyNC45OCAtNDAuOTksIC0xMjUuMjMgLTQzLjk3LCAtMTI1LjI2IC00Ni40MSBDLTEyNS4zIC00OC44NCwgLTEyNS4wMSAtNTAuOTcsIC0xMjQuMTQgLTUyLjk2IEMtMTIzLjI2IC01NC45NSwgLTEyMS4zNCAtNTYuNzgsIC0xMjAuMDEgLTU4LjM0IEMtMTE4LjY3IC01OS45MSwgLTExNy44MiAtNjEuMjEsIC0xMTYuMTMgLTYyLjM1IEMtMTE0LjQzIC02My41LCAtMTEyLjAzIC02NC42NiwgLTEwOS44NCAtNjUuMjIgQy0xMDcuNjQgLTY1Ljc4LCAtMTA0LjcyIC02NS45NSwgLTEwMi45NSAtNjUuNzEgQy0xMDEuMTcgLTY1LjQ4LCAtOTkuNDIgLTYzLjQ5LCAtOTkuMTcgLTYzLjgzIEMtOTguOTMgLTY0LjE4LCAtMTAxLjMyIC02NS41OSwgLTEwMS40OCAtNjcuNzkgQy0xMDEuNjQgLTY5Ljk4LCAtMTAxLjA1IC03My45NCwgLTEwMC4xMyAtNzcuMDMgQy05OS4yMiAtODAuMTIsIC05Ny43NiAtODMuMzIsIC05NiAtODYuMzIgQy05NC4yMyAtODkuMzIsIC05MS45OCAtOTIuNzMsIC04OS41NSAtOTUuMDIgQy04Ny4xMiAtOTcuMzIsIC04NC4xOCAtOTguODYsIC04MS40MiAtMTAwLjA4IEMtNzguNjYgLTEwMS4zLCAtNzYuMjQgLTEwMS45MywgLTcyLjk5IC0xMDIuMzMgQy02OS43MyAtMTAyLjc0LCAtNjUuMDkgLTEwMi44MSwgLTYxLjg4IC0xMDIuNTIgQy01OC42NyAtMTAyLjIyLCAtNTYuMjkgLTEwMS41NSwgLTUzLjczIC0xMDAuNTYgQy01MS4xNyAtOTkuNTcsIC00OC4yMiAtOTcuOTMsIC00Ni41MSAtOTYuNTcgQy00NC44IC05NS4yMSwgLTQzLjk4IC05Mi40MSwgLTQzLjQ4IC05Mi40IEMtNDIuOTcgLTkyLjM4LCAtNDQuMDMgLTk0LjYxLCAtNDMuNDcgLTk2LjQ4IEMtNDIuOSAtOTguMzUsIC00MS43OCAtMTAxLjA3LCAtNDAuMDggLTEwMy41OSBDLTM4LjM4IC0xMDYuMTEsIC0zNS41NCAtMTA5LjIyLCAtMzMuMjggLTExMS42MSBDLTMxLjAzIC0xMTQsIC0yOS4wOCAtMTE1Ljk1LCAtMjYuNTQgLTExNy45MyBDLTI0IC0xMTkuOTIsIC0yMS4wMSAtMTIxLjk2LCAtMTguMDYgLTEyMy41IEMtMTUuMTEgLTEyNS4wNSwgLTEyLjY2IC0xMjYuMTgsIC04LjgyIC0xMjcuMjEgQy00Ljk5IC0xMjguMjQsIDAuNDQgLTEyOS41NSwgNC45NiAtMTI5LjY3IEM5LjQ5IC0xMjkuNzksIDEzLjkyIC0xMjguOTQsIDE4LjMxIC0xMjcuOTUgQzIyLjcgLTEyNi45NywgMjcuMjMgLTEyNS42OCwgMzEuMjkgLTEyMy43NCBDMzUuMzYgLTEyMS43OSwgMzkuODUgLTExOC40MiwgNDIuNjkgLTExNi4yOCBDNDUuNTIgLTExNC4xNSwgNDYuNTMgLTExMi44MywgNDguMyAtMTEwLjk1IEM1MC4wNyAtMTA5LjA4LCA1Mi4yNiAtMTA2LjkyLCA1My4zIC0xMDUuMDMgQzU0LjM0IC0xMDMuMTMsIDUzLjg5IC0xMDAuMDcsIDU0LjU2IC05OS41OSBDNTUuMjIgLTk5LjEsIDU1LjQ4IC0xMDEuMzksIDU3LjI3IC0xMDIuMTMgQzU5LjA2IC0xMDIuODcsIDYyLjM0IC0xMDMuODUsIDY1LjMgLTEwNC4wNCBDNjguMjUgLTEwNC4yMywgNzEuOTggLTEwNC4wOCwgNzQuOTkgLTEwMy4yNyBDNzggLTEwMi40NSwgODAuNjYgLTEwMC45OCwgODMuMzYgLTk5LjE1IEM4Ni4wNiAtOTcuMzIsIDg5LjI3IC05NC45MiwgOTEuMTggLTkyLjI3IEM5My4wOSAtODkuNjEsIDk0LjAxIC04NS43LCA5NC44MSAtODMuMiBDOTUuNjIgLTgwLjcsIDk2IC03OS43MiwgOTYuMDIgLTc3LjI3IEM5Ni4wNCAtNzQuODEsIDk0Ljc2IC02OS41NCwgOTQuOTEgLTY4LjQ5IEM5NS4wNiAtNjcuNDQsIDk1LjcxIC03MC42MiwgOTYuOTQgLTcwLjk2IEM5OC4xNyAtNzEuMywgMTAwLjA1IC03MS4xOSwgMTAyLjI4IC03MC41MyBDMTA0LjUxIC02OS44OCwgMTA3Ljk4IC02OC42NiwgMTEwLjMzIC02Ny4wNCBDMTEyLjY4IC02NS40MiwgMTE0Ljg2IC02My4zNCwgMTE2LjM5IC02MC44MiBDMTE3LjkxIC01OC4yOSwgMTE5LjA4IC01NC43OSwgMTE5LjQ3IC01MS45IEMxMTkuODYgLTQ5LjAxLCAxMTkuMzkgLTQ1Ljc5LCAxMTguNyAtNDMuNDUgQzExOC4wMSAtNDEuMTEsIDExNi4zOSAtMzkuMzEsIDExNS4zMyAtMzcuODUgQzExNC4yOCAtMzYuMzgsIDExMy40MSAtMzUuMiwgMTEyLjM3IC0zNC42NSBDMTExLjMzIC0zNC4xMSwgMTA4Ljg2IC0zNC45OSwgMTA5LjExIC0zNC41OSBDMTA5LjM2IC0zNC4xOSwgMTEyLjUzIC0zMy4yMiwgMTEzLjg1IC0zMi4yNiBDMTE1LjE4IC0zMS4zLCAxMTYuNTEgLTMwLjQzLCAxMTcuMDcgLTI4LjgxIEMxMTcuNjQgLTI3LjE5LCAxMTcuNzMgLTI0LjQ3LCAxMTcuMjUgLTIyLjUzIEMxMTYuNzcgLTIwLjU5LCAxMTUuMzcgLTE4LjQ1LCAxMTQuMiAtMTcuMTcgQzExMy4wMyAtMTUuODksIDExMS42NiAtMTUuMjksIDExMC4yMyAtMTQuODQgQzEwOC43OSAtMTQuMzksIDEwNy4wMyAtMTQuMzUsIDEwNS42IC0xNC40NSBDMTA0LjE2IC0xNC41NCwgMTAzLjEyIC0xNC4zOSwgMTAxLjYyIC0xNS40MSBDMTAwLjEyIC0xNi40NCwgOTcuMjEgLTIwLjQ3LCA5Ni42MSAtMjAuNjEgQzk2LjAxIC0yMC43NCwgOTguMTYgLTE3Ljk2LCA5OC4wMyAtMTYuMjEgQzk3LjkgLTE0LjQ2LCA5Ni40NSAtMTEuNzIsIDk1Ljg1IC0xMC4xMSBDOTUuMjUgLTguNDksIDk1LjQ5IC04LjM5LCA5NC40MiAtNi41MiBDOTMuMzUgLTQuNjUsIDkxLjA2IC0wLjk4LCA4OS40NCAxLjA5IEM4Ny44MiAzLjE1LCA4Ny4zMyAzLjk4LCA4NC42OCA1Ljg4IEM4Mi4wMiA3Ljc4LCA3Ny4xMiAxMS4xMiwgNzMuNDkgMTIuNSBDNjkuODYgMTMuODgsIDY2LjYxIDE0LjEyLCA2Mi45MSAxNC4xNCBDNTkuMjIgMTQuMTYsIDU1LjEyIDEzLjU3LCA1MS4zMSAxMi42IEM0Ny41MSAxMS42NCwgNDIuOTggMTAuMjQsIDQwLjA5IDguMzUgQzM3LjIgNi40NiwgMzUuMDQgMS44OCwgMzMuOTYgMS4yNyBDMzIuODkgMC42NiwgMzQuODUgMy40MiwgMzMuNjUgNC42NyBDMzIuNDUgNS45MiwgMjkuMzMgNy44NiwgMjYuNzYgOC43OCBDMjQuMTkgOS43MSwgMjAuOTkgMTAuMjMsIDE4LjIzIDEwLjIzIEMxNS40NyAxMC4yMywgMTIuODMgOS44MSwgMTAuMTggOC43NiBDNy41MyA3LjcxLCA0LjA0IDUuNDEsIDIuMzQgMy45NSBDMC42NCAyLjQ5LCAwLjM5IDAuNjYsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PC9nPjxtYXNrPjwvbWFzaz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4NjEuNTg5MDY1NTUxNzU3OCA1MTEuNDY1NzU5Mjc3MzQzNzUpIHJvdGF0ZSgwIDQ2Ljg3NSAxMikiPjx0ZXh0IHg9IjAiIHk9IjAiIGZvbnQtZmFtaWx5PSJDYXNjYWRpYSwgU2Vnb2UgVUkgRW1vamkiIGZvbnQtc2l6ZT0iMjBweCIgZmlsbD0idHJhbnNwYXJlbnQiIHRleHQtYW5jaG9yPSJzdGFydCIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPmludGVybmV0PC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2OC41MDg0OTA0NzE1ODI2NiAxMjExLjEwOTM0NDQ4MjQyMTkpIHJvdGF0ZSgwIC0yLjUzOTIwOTY1NDUyMzQ2MSA0MC4wNTQ4MDk1NzAzMTI1KSI+PHBhdGggZD0iTTAgMCBDLTEuNzkgMTYuMzIsIC0zLjkzIDM0LjY3LCAtNS4wOCA4MC4xMSBNMCAwIEMwLjE4IDE3LjI0LCAtMS4zNyAzMy43MiwgLTUuMDggODAuMTEiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2OC41MDg0OTA0NzE1ODI2NiAxMjExLjEwOTM0NDQ4MjQyMTkpIHJvdGF0ZSgwIC0yLjUzOTIwOTY1NDUyMzQ2MSA0MC4wNTQ4MDk1NzAzMTI1KSI+PHBhdGggZD0iTS0xMS43MiA1Ni4wMSBDLTEwLjU4IDU5LjgsIC0xMC4xMiA2NS43NCwgLTUuMDggODAuMTEgTS0xMS43MiA1Ni4wMSBDLTkuNSA2MS42NywgLTguNjUgNjYuNjUsIC01LjA4IDgwLjExIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjguNTA4NDkwNDcxNTgyNjYgMTIxMS4xMDkzNDQ0ODI0MjE5KSByb3RhdGUoMCAtMi41MzkyMDk2NTQ1MjM0NjEgNDAuMDU0ODA5NTcwMzEyNSkiPjxwYXRoIGQ9Ik01LjMyIDU3LjM4IEMyLjcgNjEuMDMsIC0wLjYyIDY2LjY3LCAtNS4wOCA4MC4xMSBNNS4zMiA1Ny4zOCBDNC4wNCA2Mi44NiwgMS4zOSA2Ny41NSwgLTUuMDggODAuMTEiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjwvZz48bWFzaz48L21hc2s+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NC40NTIwNzIxNDM1NTQ2OSAxOTcuNjE2NDU1MDc4MTI1KSByb3RhdGUoMCA1OC43Mzk3MTU1NzYxNzE4NzUgNTMuNDc5NDMxMTUyMzQzNzUpIj48cGF0aCBkPSJNNTUuMTkgMC41IEM2NC4zNiAtMC43MiwgNzYuMTYgMi42LCA4NC44OCA2LjM5IEM5My42IDEwLjE5LCAxMDIuMjQgMTYuMTQsIDEwNy41MSAyMy4yOCBDMTEyLjc5IDMwLjQxLCAxMTUuOTMgNDAuMzcsIDExNi41MiA0OS4yMSBDMTE3LjEyIDU4LjA0LCAxMTUuMTMgNjguMDYsIDExMS4wOCA3Ni4zIEMxMDcuMDMgODQuNTMsIDEwMC4yNSA5My40NywgOTIuMjMgOTguNjMgQzg0LjIgMTAzLjc5LCA3Mi45NSAxMDYuNzQsIDYyLjkyIDEwNy4yNCBDNTIuOSAxMDcuNzUsIDQxLjA4IDEwNS42LCAzMi4wOSAxMDEuNjUgQzIzLjEgOTcuNjksIDE0LjI0IDkxLjA3LCA4Ljk4IDgzLjUgQzMuNzIgNzUuOTMsIDEgNjUuMzYsIDAuNTQgNTYuMjQgQzAuMDggNDcuMTMsIDEuODUgMzYuNTUsIDYuMjEgMjguODEgQzEwLjU4IDIxLjA3LCAxOC4yMSAxNC41MywgMjYuNzIgOS44MSBDMzUuMjQgNS4wOCwgNTEuOCAxLjg5LCA1Ny4zMSAwLjQ1IEM2Mi44MSAtMC45OCwgNTkuNjUgMC40MywgNTkuNzcgMS4xNyBNNjYuNTIgMC40NyBDNzUuODEgMC45MSwgODcuNDUgNS41OSwgOTUuMTkgMTEuMzMgQzEwMi45MiAxNy4wNywgMTA5LjIyIDI2Ljc0LCAxMTIuOTMgMzQuOTQgQzExNi42NSA0My4xMywgMTE4LjcyIDUxLjg5LCAxMTcuNDcgNjAuNDkgQzExNi4yMyA2OS4xLCAxMTEuOTEgNzkuNTIsIDEwNS40NyA4Ni41NyBDOTkuMDMgOTMuNjEsIDg4LjM1IDk5LjU2LCA3OC44MyAxMDIuNzYgQzY5LjMyIDEwNS45NiwgNTcuNjcgMTA3LjAyLCA0OC40IDEwNS43NSBDMzkuMTIgMTA0LjQ5LCAzMC42MiAxMDAuNjMsIDIzLjE4IDk1LjE2IEMxNS43NSA4OS43LCA3LjQyIDgxLjA5LCAzLjgxIDcyLjk4IEMwLjE5IDY0Ljg2LCAtMC4yNiA1NS4zMywgMS41IDQ2LjQ1IEMzLjI2IDM3LjU3LCA4LjU5IDI2LjcsIDE0LjM5IDE5LjcxIEMyMC4xOCAxMi43MiwgMjcuMzIgNy44NywgMzYuMjcgNC41MSBDNDUuMjIgMS4xNCwgNjIuODUgMC4xMywgNjguMDggLTAuNDYgQzczLjMxIC0xLjA1LCA2Ny42OSAtMC4wMywgNjcuNjMgMC45OCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAxLjQzNzc4NjUxMDg0NjM3IDIzOS4yODAyMTc4MDg2NDczNikgcm90YXRlKDAgMTEuNzE4NzUgMTIpIj48dGV4dCB4PSIxMS43MTg3NSIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+T1M8L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDQ5Ljg0OTM0OTk3NTU4NTk0IDExNDcuMDgyMDkyMjg1MTU2Mikgcm90YXRlKDAgNTguNzM5NzE1NTc2MTcxODc1IDUzLjQ3OTQzMTE1MjM0Mzc1KSI+PHBhdGggZD0iTTgwLjI4IDMuMDUgQzg5LjM3IDUuNTIsIDk5LjIgMTMuMjIsIDEwNS4zIDIwLjQgQzExMS40IDI3LjU4LCAxMTUuNzQgMzcuMTcsIDExNi44OSA0Ni4xMSBDMTE4LjA1IDU1LjA1LCAxMTYuMDMgNjUuNzMsIDExMi4yMiA3NC4wNCBDMTA4LjQxIDgyLjM2LCAxMDEuNTkgOTAuNTYsIDk0LjA0IDk2IEM4Ni40OCAxMDEuNDUsIDc2LjM1IDEwNS40OCwgNjYuOSAxMDYuNzMgQzU3LjQ1IDEwNy45OCwgNDYuNDQgMTA2Ljk2LCAzNy4zMyAxMDMuNTEgQzI4LjIyIDEwMC4wNSwgMTguNDIgOTMuMjUsIDEyLjI1IDg2IEM2LjA5IDc4Ljc1LCAxLjU5IDY4Ljc5LCAwLjMyIDYwLjAyIEMtMC45NSA1MS4yNSwgMC43OSA0MS4zNiwgNC42MiAzMy4zNiBDOC40NSAyNS4zNiwgMTUuNjkgMTcuMzcsIDIzLjMgMTIuMDEgQzMwLjkyIDYuNjUsIDM4LjgzIDEuNTYsIDUwLjMxIDEuMjEgQzYxLjggMC44NiwgODMuNjkgNi44NywgOTIuMjMgOS44OSBDMTAwLjc3IDEyLjkyLCAxMDEuOTMgMTguNzQsIDEwMS41NCAxOS4zNSBNMzEuOTkgNC45NSBDNDAuMzYgMC41MiwgNTMuOTMgMC4wNywgNjMuOTkgMC44NCBDNzQuMDYgMS42LCA4NC4zMiA0Ljg0LCA5Mi4zNyA5LjU1IEMxMDAuNDIgMTQuMjcsIDEwOC4yMyAyMS4zMSwgMTEyLjI5IDI5LjEzIEMxMTYuMzUgMzYuOTUsIDExNy4zOCA0Ny42NCwgMTE2Ljc0IDU2LjQ3IEMxMTYuMTEgNjUuMywgMTEzLjY5IDc0LjU1LCAxMDguNSA4Mi4xMSBDMTAzLjMgODkuNjcsIDk0LjY0IDk3Ljg4LCA4NS41NyAxMDEuODEgQzc2LjUgMTA1Ljc0LCA2My45IDEwNi4yOSwgNTQuMDcgMTA1LjY4IEM0NC4yNSAxMDUuMDcsIDM0LjUxIDEwMywgMjYuNjMgOTguMTcgQzE4Ljc0IDkzLjMzLCAxMS4zOCA4NC43NiwgNi43NCA3Ni42NiBDMi4xMSA2OC41NSwgLTEuOTMgNTguMTYsIC0xLjE4IDQ5LjUzIEMtMC40MiA0MC45LCA1LjcyIDMyLjA5LCAxMS4yNiAyNC44NyBDMTYuODEgMTcuNjUsIDI4LjE1IDkuNDksIDMyLjA4IDYuMjEgQzM2LjAxIDIuOTMsIDM0LjM3IDQuNDcsIDM0Ljg0IDUuMTkiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ5Ni44MzUwNjQzNDI4Nzc1NiAxMTg4Ljc0NTg1NTAxNTY3ODcpIHJvdGF0ZSgwIDExLjcxODc1IDEyKSI+PHRleHQgeD0iMTEuNzE4NzUiIHk9IjAiIGZvbnQtZmFtaWx5PSJDYXNjYWRpYSwgU2Vnb2UgVUkgRW1vamkiIGZvbnQtc2l6ZT0iMjBweCIgZmlsbD0iIzFlMWUxZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPk9TPC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ2NS42MzAxNDIyMTE5MTQwNiAxMjAuNDY1NzU5Mjc3MzQzNzUpIHJvdGF0ZSgwIDEzMi4zODM1NzU0Mzk0NTMxMiAyMzQuMDgyMTgzODM3ODkwNjIpIj48cGF0aCBkPSJNMCAwIEM1NC4wNiAtMS42OCwgMTA3LjAyIC0yLjAzLCAyNjQuNzcgMCBNMCAwIEM2My43IDAuODcsIDEyNy41IDEuNjQsIDI2NC43NyAwIE0yNjQuNzcgMCBDMjY2LjM1IDE0MS4zMSwgMjY2LjEzIDI4NC42OSwgMjY0Ljc3IDQ2OC4xNiBNMjY0Ljc3IDAgQzI2My4xOCAxNDYuODYsIDI2Mi45NCAyOTMuNzIsIDI2NC43NyA0NjguMTYgTTI2NC43NyA0NjguMTYgQzIwMS4wNyA0NjguNzEsIDEzOS44NiA0NjcuODEsIDAgNDY4LjE2IE0yNjQuNzcgNDY4LjE2IEMyMDUuMzcgNDY5LjM0LCAxNDUuNzcgNDY5LjE2LCAwIDQ2OC4xNiBNMCA0NjguMTYgQy0wLjQ2IDMxNy40MSwgLTEuMzIgMTY3LjU2LCAwIDAgTTAgNDY4LjE2IEMxLjczIDMxOS43NSwgMi4yNSAxNzIuMzYsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTUuNjAyNzM3NDI2NzU3OCA0MTMuMjg3NTk3NjU2MjUpIHJvdGF0ZSgwIDgxLjA5NTg1NTcxMjg5MDYyIDE4Ljg0OTMzNDcxNjc5Njg3NSkiPjxwYXRoIGQ9Ik0tMC4wNiAtMS45NCBMMTYyLjMyIDAuNjUgTDE2MS43NSAzOS41MiBMLTAuMiAzNS44MyIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGw9IiNmZmVjOTkiPjwvcGF0aD48cGF0aCBkPSJNMCAwIEM2NC4wOSAtMC4yLCAxMjYuNDggMi40NCwgMTYyLjE5IDAgTTAgMCBDNTkuOCAxLjExLCAxMjEuNCAwLjAxLCAxNjIuMTkgMCBNMTYyLjE5IDAgQzE2MC43IDEyLjg2LCAxNjMuNTggMjYuMDEsIDE2Mi4xOSAzNy43IE0xNjIuMTkgMCBDMTYyLjEgMTQuNTMsIDE2Mi4wNSAyNy4xNSwgMTYyLjE5IDM3LjcgTTE2Mi4xOSAzNy43IEMxMDAuNzcgMzkuNDksIDM5Ljg4IDM3LjkxLCAwIDM3LjcgTTE2Mi4xOSAzNy43IEMxMTYuMjMgMzguNjEsIDY5LjI4IDM4Ljg4LCAwIDM3LjcgTTAgMzcuNyBDMC4yNyAyMS4zMSwgMS43MSA5Ljc1LCAwIDAgTTAgMzcuNyBDMC4zMyAyMi44LCAtMC4xMyA5LjIsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTI2LjM4NjA5MzEzOTY0ODQgNDIwLjEzNjkzMjM3MzA0NjkpIHJvdGF0ZSgwIDcwLjMxMjUgMTIpIj48dGV4dCB4PSI3MC4zMTI1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj5VRFAgRGF0YWdyYW08L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODQuMzk3NTA2NzEzODY3MTkgMTIxOS42NTc1MDEyMjA3MDMxKSByb3RhdGUoMCA4Mi44NDkzMDQxOTkyMTg3NSAxOC40MTA5ODAyMjQ2MDkzNzUpIj48cGF0aCBkPSJNLTAuMzkgLTEuMTIgTDE2NC42OCAxLjM4IEwxNjYuMTkgMzUuOTIgTC0wLjY2IDM2LjA5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbD0iI2ZmZWM5OSI+PC9wYXRoPjxwYXRoIGQ9Ik0wIDAgQzUzLjQ4IDIuMDMsIDEwNy41MSAyLjEsIDE2NS43IDAgTTAgMCBDNjUuMjcgLTAuNzksIDEzMi43MiAtMC45NiwgMTY1LjcgMCBNMTY1LjcgMCBDMTY2LjAyIDEwLjg3LCAxNjcuMDIgMjMuNzcsIDE2NS43IDM2LjgyIE0xNjUuNyAwIEMxNjQuOTEgMTQuMzEsIDE2NS4zNCAyNy4xMSwgMTY1LjcgMzYuODIgTTE2NS43IDM2LjgyIEMxMzAuODUgMzguMDMsIDk3LjEzIDM2LjQxLCAwIDM2LjgyIE0xNjUuNyAzNi44MiBDMTA4LjQ5IDM2LjQxLCA1My4zNCAzNy43OSwgMCAzNi44MiBNMCAzNi44MiBDMC41MiAyOC4zMiwgMi4yMiAxNy44MiwgMCAwIE0wIDM2LjgyIEMtMC4xMyAyOC4xNywgLTAuMzQgMTcuMTYsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTE0LjUxMjQzNTkxMzA4NTk0IDEyMjYuMDY4NDgxNDQ1MzEyNSkgcm90YXRlKDAgNTIuNzM0Mzc1IDEyKSI+PHRleHQgeD0iNTIuNzM0Mzc1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj5JUCBQYWNrZXQ8L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4LjgwODIxMjI4MDI3MzQ0IDMzOC43NjcwODk4NDM3NSkgcm90YXRlKDAgMTE3LjkxNzc4NTY0NDUzMTI1IDI5KSI+PHBhdGggZD0iTTAgMCBDNzAuMDggMi4xMSwgMTQwLjk2IDEuODUsIDIzNS44NCAwIE0wIDAgQzgzLjUxIC0xLjQzLCAxNjUuNjggLTIuMTksIDIzNS44NCAwIE0yMzUuODQgMCBDMjM0LjQzIDE0Ljk4LCAyMzUuODYgMjYuNDUsIDIzNS44NCA1OCBNMjM1Ljg0IDAgQzIzNC45NiAxNS4wNCwgMjM1LjcxIDMxLjc2LCAyMzUuODQgNTggTTIzNS44NCA1OCBDMTQ1Ljc5IDU1Ljk5LCA1NC42NyA1Ny4zOSwgMCA1OCBNMjM1Ljg0IDU4IEMxODkuNDMgNTYuMDQsIDE0MS45NyA1Ni42NSwgMCA1OCBNMCA1OCBDMC43NSA0MS4zNSwgLTAuNTIgMjEuNzksIDAgMCBNMCA1OCBDMC43MiA0My44LCAtMC4yMyAzMC40MywgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjEuMjU3MjQ3OTI0ODA0NjkgMzU1Ljc2NzA4OTg0Mzc1KSByb3RhdGUoMCAxMDUuNDY4NzUgMTIpIj48dGV4dCB4PSIxMDUuNDY4NzUiIHk9IjAiIGZvbnQtZmFtaWx5PSJDYXNjYWRpYSwgU2Vnb2UgVUkgRW1vamkiIGZvbnQtc2l6ZT0iMjBweCIgZmlsbD0iIzFlMWUxZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPm5ldGNhdCAxMC44LjAuMSA4MDwvdGV4dD48L2c+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODEuNTc0MTY1MDQ1NDIyODMgMzM0LjM4MzQ4Mzg4NjcxODc1KSByb3RhdGUoMCAtMTYuNjY3ODgwNTMyNDYwMDMyIC0xOC41Mjg5OTY1OTY3NzgzMTMpIj48cGF0aCBkPSJNMCAwIEMtOS4wNCAtOS4zMiwgLTE3LjA1IC0xOC4xMiwgLTMzLjM0IC0zNy4wNiBNMCAwIEMtOS44OSAtMTAuNTYsIC0xOSAtMjEuNjMsIC0zMy4zNCAtMzcuMDYiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4MS41NzQxNjUwNDU0MjI4MyAzMzQuMzgzNDgzODg2NzE4NzUpIHJvdGF0ZSgwIC0xNi42Njc4ODA1MzI0NjAwMzIgLTE4LjUyODk5NjU5Njc3ODMxMykiPjxwYXRoIGQ9Ik0tMTEuMjcgLTI1LjQ3IEMtMTcuNDcgLTI4LjM2LCAtMjIuNjMgLTMwLjc0LCAtMzMuMzQgLTM3LjA2IE0tMTEuMjcgLTI1LjQ3IEMtMTcuODkgLTI4LjcxLCAtMjMuNzYgLTMyLjQ3LCAtMzMuMzQgLTM3LjA2IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODEuNTc0MTY1MDQ1NDIyODMgMzM0LjM4MzQ4Mzg4NjcxODc1KSByb3RhdGUoMCAtMTYuNjY3ODgwNTMyNDYwMDMyIC0xOC41Mjg5OTY1OTY3NzgzMTMpIj48cGF0aCBkPSJNLTIzLjg4IC0xNCBDLTI2LjkxIC0xOS43NywgLTI4Ljg5IC0yNS4wNCwgLTMzLjM0IC0zNy4wNiBNLTIzLjg4IC0xNCBDLTI2Ljg5IC0yMC41NSwgLTI5LjE0IC0yNy42LCAtMzMuMzQgLTM3LjA2IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48L2c+PG1hc2s+PC9tYXNrPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzk0LjgzNTUyNTUxMjY5NTMgMTMyOS44MzU0MDM0NDIzODI4KSByb3RhdGUoMCAxMzguOTU4ODYyMzA0Njg3NSAyOSkiPjxwYXRoIGQ9Ik0wIDAgQzEwNy4zNCAtMS45NCwgMjE2Ljg3IC0wLjY3LCAyNzcuOTIgMCBNMCAwIEMxMDguMzEgLTAuMzUsIDIxNy4yNyAtMC41MSwgMjc3LjkyIDAgTTI3Ny45MiAwIEMyNzYuNTYgMTQuNDUsIDI3Ny40MyAzMS4yNSwgMjc3LjkyIDU4IE0yNzcuOTIgMCBDMjc4LjA0IDIxLjgxLCAyNzguNDkgNDIuOTksIDI3Ny45MiA1OCBNMjc3LjkyIDU4IEMyMTIuNTEgNTguODgsIDE0NS45IDU3LjU4LCAwIDU4IE0yNzcuOTIgNTggQzE3MS4zOCA2MC40NywgNjMuODIgNjAuNjMsIDAgNTggTTAgNTggQzEuMTYgNDMuNzEsIC0wLjI2IDI2LjcsIDAgMCBNMCA1OCBDMC42MyA0NC4zNSwgMC44OCAzMy4wNSwgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MTAuNzQ3NTEyODE3MzgyOCAxMzQ2LjgzNTQwMzQ0MjM4MjgpIHJvdGF0ZSgwIDEyMy4wNDY4NzUgMTIpIj48dGV4dCB4PSIxMjMuMDQ2ODc1IiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj5uZXRjYXQgLWwgMTAuOC4wLjEgODA8L3RleHQ+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4OC41ODkwNjU1NTE3NTc4IDE0MS40NjU3NTkyNzczNDM3NSkgcm90YXRlKDAgODIuMDMxMjUgMTIpIj48dGV4dCB4PSIwIiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJzdGFydCIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPndvbnR1bihjbGllbnQpPC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjA0MTEyMjQzNjUyMzQ0IDk1OC42MDI2NjExMzI4MTI1KSByb3RhdGUoMCAxMzIuMzgzNTc1NDM5NDUzMTIgMjM0LjA4MjE4MzgzNzg5MDYyKSI+PHBhdGggZD0iTTAgMCBDODMuNjkgMi4zMiwgMTY2LjUgMi4wNSwgMjY0Ljc3IDAgTTAgMCBDOTEuODkgMC4wNCwgMTgzLjQ4IDEuMTUsIDI2NC43NyAwIE0yNjQuNzcgMCBDMjY0LjIzIDExNi42LCAyNjQuODUgMjMzLjI2LCAyNjQuNzcgNDY4LjE2IE0yNjQuNzcgMCBDMjY1LjIyIDEzMi4wNSwgMjY1LjM1IDI2NC45MiwgMjY0Ljc3IDQ2OC4xNiBNMjY0Ljc3IDQ2OC4xNiBDMTc3LjM0IDQ2Ni43NSwgODcuMTMgNDY1LjQ3LCAwIDQ2OC4xNiBNMjY0Ljc3IDQ2OC4xNiBDMjAwLjkzIDQ2Ny42OSwgMTM2LjU1IDQ2OC41OSwgMCA0NjguMTYgTTAgNDY4LjE2IEMwLjQ1IDM1NC41NywgLTAuMzQgMjQwLjE2LCAwIDAgTTAgNDY4LjE2IEMtMC40OSAzMzkuNiwgLTAuMDQgMjExLjUzLCAwIDAiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYzLjU3MTU0ODQ2MTkxNDA2IDEzODcuNzM5NjI0MDIzNDM3NSkgcm90YXRlKDAgODIuMDMxMjUgMTIpIj48dGV4dCB4PSIwIiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJzdGFydCIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPndvbnR1bihzZXJ2ZXIpPC90ZXh0PjwvZz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3LjYzMDE3MjcyOTQ5MjE4OCAxMCkgcm90YXRlKDAgMzYyLjA4MjE2ODU3OTEwMTU2IDMwMS41ODkwNTAyOTI5Njg3NSkiPjxwYXRoIGQ9Ik0wIDAgQzE4OS42OCAtMC44NSwgMzc5LjI4IC0wLjgzLCA3MjQuMTYgMCBNMCAwIEMxOTguMTggLTIuODQsIDM5Ny4yIC0zLjA4LCA3MjQuMTYgMCBNNzI0LjE2IDAgQzcyNS44MyAxMjYuOTYsIDcyNi4wMiAyNTMuNjIsIDcyNC4xNiA2MDMuMTggTTcyNC4xNiAwIEM3MjMuODcgMjAzLjcsIDcyNC41OSA0MDcuMzQsIDcyNC4xNiA2MDMuMTggTTcyNC4xNiA2MDMuMTggQzQzNi41NSA2MDUuMDIsIDE0OS4zNiA2MDQuNjIsIDAgNjAzLjE4IE03MjQuMTYgNjAzLjE4IEM1NzIuOTggNjAwLjksIDQyMi4xNSA2MDAuOTcsIDAgNjAzLjE4IE0wIDYwMy4xOCBDLTIuNjIgNDQ3LjMxLCAtMS41NCAyOTIuMjUsIDAgMCBNMCA2MDMuMTggQzIuMzcgNDM2LjA2LCAyLjI4IDI2OC41NCwgMCAwIiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0NS41ODkwNjU1NTE3NTc4MSAzOS40NjU3NTkyNzczNDM3NSkgcm90YXRlKDAgMTA1LjQ2ODc1IDEyKSI+PHRleHQgeD0iMCIgeT0iMCIgZm9udC1mYW1pbHk9IkNhc2NhZGlhLCBTZWdvZSBVSSBFbW9qaSIgZm9udC1zaXplPSIyMHB4IiBmaWxsPSIjMWUxZTFlIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIHN0eWxlPSJ3aGl0ZS1zcGFjZTogcHJlOyIgZGlyZWN0aW9uPSJsdHIiIGRvbWluYW50LWJhc2VsaW5lPSJ0ZXh0LWJlZm9yZS1lZGdlIj5jbGllbnQ6IDE3Mi4xOC4wLjE8L3RleHQ+PC9nPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAgODgyLjA4MjEyMjgwMjczNDQpIHJvdGF0ZSgwIDM2Mi4wODIxNjg1NzkxMDE1NiAzMDEuNTg5MDUwMjkyOTY4NzUpIj48cGF0aCBkPSJNMCAwIEMxNDguNzMgMS4zNiwgMjk3LjAyIDEuODcsIDcyNC4xNiAwIE0wIDAgQzI3NC45MSAyLjQ5LCA1NDkuNDUgMi41NCwgNzI0LjE2IDAgTTcyNC4xNiAwIEM3MjQuNzYgMjM0LjQyLCA3MjQuODcgNDY2Ljk3LCA3MjQuMTYgNjAzLjE4IE03MjQuMTYgMCBDNzI1LjE3IDIwOC40MSwgNzI1LjYxIDQxNy4yNSwgNzI0LjE2IDYwMy4xOCBNNzI0LjE2IDYwMy4xOCBDNTU0LjQ0IDYwMy40NywgMzg1LjE5IDYwMy41LCAwIDYwMy4xOCBNNzI0LjE2IDYwMy4xOCBDNTEzLjUyIDYwNS4yLCAzMDIuMzUgNjA1LjE4LCAwIDYwMy4xOCBNMCA2MDMuMTggQzEuMzUgNDMzLjgxLCAxLjAyIDI2NC4wNSwgMCAwIE0wIDYwMy4xOCBDLTEuNDIgNDUzLjgxLCAtMC44NyAzMDUuMjIsIDAgMCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyOTguMTc4MTQ2MzYyMzA0OCAxMjg2LjQyNzAyNzAyNDQ1MDQpIHJvdGF0ZSgwIDc3LjUwMDM2MTg2MDcxMDU0IC0zMi43NTE3MzYyMTY1OTAxOSkiPjxwYXRoIGQ9Ik0wIDAgQzQyLjE0IC0xOS4zOSwgODkuNDcgLTM5LjcxLCAxNTUgLTY1LjUgTTAgMCBDMzkuMzIgLTE2LjYxLCA3OS4yNiAtMzMuNjgsIDE1NSAtNjUuNSIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjk4LjE3ODE0NjM2MjMwNDggMTI4Ni40MjcwMjcwMjQ0NTA0KSByb3RhdGUoMCA3Ny41MDAzNjE4NjA3MTA1NCAtMzIuNzUxNzM2MjE2NTkwMTkpIj48cGF0aCBkPSJNMTM2LjY3IC00OC41IEMxNDAuMTMgLTUzLCAxNDguMzUgLTU5LjQ0LCAxNTUgLTY1LjUgTTEzNi42NyAtNDguNSBDMTQxLjA3IC01My4wOCwgMTQ2LjMxIC01Ny44NCwgMTU1IC02NS41IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyOTguMTc4MTQ2MzYyMzA0OCAxMjg2LjQyNzAyNzAyNDQ1MDQpIHJvdGF0ZSgwIDc3LjUwMDM2MTg2MDcxMDU0IC0zMi43NTE3MzYyMTY1OTAxOSkiPjxwYXRoIGQ9Ik0xMzAuMDMgLTY0LjI2IEMxMzUuNTMgLTY0LjMsIDE0NS42NSAtNjYuMjMsIDE1NSAtNjUuNSBNMTMwLjAzIC02NC4yNiBDMTM2LjA0IC02NC44MywgMTQyLjk2IC02NS41OCwgMTU1IC02NS41IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48L2c+PG1hc2s+PC9tYXNrPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTIwLjg2MzA1MjM2ODE2NDEgMTI1NC4wNTQ3NzkwNTI3MzQ0KSByb3RhdGUoMCAzLjY3MjI0NzUxMTcxNjk4OTMgMzYuMzgzNDY4NjI3OTI5NjkpIj48cGF0aCBkPSJNMCAwIEMxLjgyIDI0LjQyLCA1LjM2IDUyLjkxLCA3LjM0IDcyLjc3IE0wIDAgQzIuMjggMTcuNzEsIDIuNjkgMzMuNiwgNy4zNCA3Mi43NyIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTIwLjg2MzA1MjM2ODE2NDEgMTI1NC4wNTQ3NzkwNTI3MzQ0KSByb3RhdGUoMCAzLjY3MjI0NzUxMTcxNjk4OTMgMzYuMzgzNDY4NjI3OTI5NjkpIj48cGF0aCBkPSJNLTMuNjkgNTAuMzMgQy0wLjIyIDU2LjY4LCA0LjY0IDY3LjE1LCA3LjM0IDcyLjc3IE0tMy42OSA1MC4zMyBDLTAuNDcgNTYuNDIsIDAuNzkgNjAuNjYsIDcuMzQgNzIuNzciIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUyMC44NjMwNTIzNjgxNjQxIDEyNTQuMDU0Nzc5MDUyNzM0NCkgcm90YXRlKDAgMy42NzIyNDc1MTE3MTY5ODkzIDM2LjM4MzQ2ODYyNzkyOTY5KSI+PHBhdGggZD0iTTEzLjMyIDQ4LjQ5IEMxMC42OCA1NS42MiwgOS40NSA2Ni43NCwgNy4zNCA3Mi43NyBNMTMuMzIgNDguNDkgQzEyLjU5IDU0Ljg2LCA5LjkyIDU5LjUzLCA3LjM0IDcyLjc3IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48L2c+PG1hc2s+PC9tYXNrPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMyLjk5Njk2MzUwMDk3NjU2IDg5NC42MzAwMzU0MDAzOTA2KSByb3RhdGUoMCAxMDUuNDY4NzUgMTIpIj48dGV4dCB4PSIwIiB5PSIwIiBmb250LWZhbWlseT0iQ2FzY2FkaWEsIFNlZ29lIFVJIEVtb2ppIiBmb250LXNpemU9IjIwcHgiIGZpbGw9IiMxZTFlMWUiIHRleHQtYW5jaG9yPSJzdGFydCIgc3R5bGU9IndoaXRlLXNwYWNlOiBwcmU7IiBkaXJlY3Rpb249Imx0ciIgZG9taW5hbnQtYmFzZWxpbmU9InRleHQtYmVmb3JlLWVkZ2UiPnNlcnZlcjogMTcyLjE4LjAuMjwvdGV4dD48L2c+PGcgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjguNDI0Njk3ODc1OTc2NTYgMTA2OC4xOTE3MTE0MjU3ODEyKSByb3RhdGUoMCAwLjQzODMzOTIzMzM5ODQzNzUgMzQuMTkxNzcyNDYwOTM3NSkiPjxwYXRoIGQ9Ik0wIDAgQy0xLjc0IDIzLjEzLCAtMC41NCA0Ny40MiwgMC44OCA2OC4zOCBNMCAwIEMwLjM5IDIzLjc0LCAtMC40NyA0NS45NCwgMC44OCA2OC4zOCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY4LjQyNDY5Nzg3NTk3NjU2IDEwNjguMTkxNzExNDI1NzgxMikgcm90YXRlKDAgMC40MzgzMzkyMzMzOTg0Mzc1IDM0LjE5MTc3MjQ2MDkzNzUpIj48cGF0aCBkPSJNLTguNDkgNDUuMjEgQy02Ljg1IDUyLjY5LCAtMi43IDYxLjMyLCAwLjg4IDY4LjM4IE0tOC40OSA0NS4yMSBDLTQuNzggNTMuNywgLTIuNzcgNjAuNTgsIDAuODggNjguMzgiIHN0cm9rZT0iIzFlMWUxZSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2OC40MjQ2OTc4NzU5NzY1NiAxMDY4LjE5MTcxMTQyNTc4MTIpIHJvdGF0ZSgwIDAuNDM4MzM5MjMzMzk4NDM3NSAzNC4xOTE3NzI0NjA5Mzc1KSI+PHBhdGggZD0iTTguNiA0NC42MSBDNC4zMiA1Mi4yNywgMi41NCA2MS4xMSwgMC44OCA2OC4zOCBNOC42IDQ0LjYxIEM2LjUyIDUzLjE4LCAyLjc0IDYwLjI3LCAwLjg4IDY4LjM4IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48L2c+PG1hc2s+PC9tYXNrPjxnIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzM4LjUwNjg1MTE5NjI4OTA2IDgxNy40NTIwODc0MDIzNDM4KSByb3RhdGUoMCAtODYuMzU2MTU1Mzk1NTA3ODEgODIuODQ5MzA0MTk5MjE4NzUpIj48cGF0aCBkPSJNLTAuNzIgMC44MiBDLTI2LjkxIDUuMzgsIC0xMjkuMDUgLTEuMTYsIC0xNTcuNTYgMjYuNTEgQy0xODYuMDcgNTQuMTcsIC0xNjkuMzEgMTQzLjU0LCAtMTcxLjc5IDE2Ni44MSBNMS4xIDAuMiBDLTI0LjY1IDQuOTksIC0xMjYuMzEgMC4yMiwgLTE1NS4xOCAyNy42OSBDLTE4NC4wNCA1NS4xNywgLTE2OS4yNiAxNDEuNzYsIC0xNzIuMDcgMTY1LjA0IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzguNTA2ODUxMTk2Mjg5MDYgODE3LjQ1MjA4NzQwMjM0MzgpIHJvdGF0ZSgwIC04Ni4zNTYxNTUzOTU1MDc4MSA4Mi44NDkzMDQxOTkyMTg3NSkiPjxwYXRoIGQ9Ik0tMTgxIDE0MS42OSBDLTE3Ny40NyAxNDYuODUsIC0xNzcuNiAxNTUuNTcsIC0xNzIuMDcgMTY1LjA0IE0tMTgxIDE0MS42OSBDLTE3Ni41NSAxNDkuOSwgLTE3Mi45OSAxNjAuMzcsIC0xNzIuMDcgMTY1LjA0IiBzdHJva2U9IiMxZTFlMWUiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+PC9wYXRoPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzguNTA2ODUxMTk2Mjg5MDYgODE3LjQ1MjA4NzQwMjM0MzgpIHJvdGF0ZSgwIC04Ni4zNTYxNTUzOTU1MDc4MSA4Mi44NDkzMDQxOTkyMTg3NSkiPjxwYXRoIGQ9Ik0tMTYzLjkxIDE0MS40MiBDLTE2NC44NyAxNDYuNTQsIC0xNjkuNSAxNTUuMzQsIC0xNzIuMDcgMTY1LjA0IE0tMTYzLjkxIDE0MS40MiBDLTE2Ni4xNiAxNDkuNzgsIC0xNjkuMzEgMTYwLjM2LCAtMTcyLjA3IDE2NS4wNCIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PC9nPjxtYXNrPjwvbWFzaz48ZyBzdHJva2UtbGluZWNhcD0icm91bmQiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4Ny40OTMxNzkzMjEyODkxIDU1Mi42ODQ5MzY1MjM0Mzc1KSByb3RhdGUoMCAtOTkuMDY4NTExOTYyODkwNjIgNjQpIj48cGF0aCBkPSJNLTAuMDIgMC42NSBDLTUuNjggMTcuOCwgLTEuNDQgODAuNTYsIC0zNC4zOSAxMDEuOTggQy02Ny4zNSAxMjMuMzksIC0xNzAuNTggMTI1LjAxLCAtMTk3Ljc1IDEyOS4xNiBNLTEuNDkgLTAuMDUgQy02Ljc1IDE3LjMzLCAwLjU2IDgxLjk1LCAtMzIuMjUgMTAzLjIgQy02NS4wNSAxMjQuNDUsIC0xNzAuODggMTIzLjM5LCAtMTk4LjMxIDEyNy40MyIgc3Ryb2tlPSIjMWUxZTFlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiPjwvcGF0aD48L2c+PC9nPjxtYXNrPjwvbWFzaz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMjAuNDUyMDQxNjI1OTc2NTYgNzM1LjQzODM1NDQ5MjE4NzUpIHJvdGF0ZSgwIDQ2Ljg3NSAxMikiPjx0ZXh0IHg9IjAiIHk9IjAiIGZvbnQtZmFtaWx5PSJDYXNjYWRpYSwgU2Vnb2UgVUkgRW1vamkiIGZvbnQtc2l6ZT0iMjBweCIgZmlsbD0iIzFlMWUxZSIgdGV4dC1hbmNob3I9InN0YXJ0IiBzdHlsZT0id2hpdGUtc3BhY2U6IHByZTsiIGRpcmVjdGlvbj0ibHRyIiBkb21pbmFudC1iYXNlbGluZT0idGV4dC1iZWZvcmUtZWRnZSI+aW50ZXJuZXQ8L3RleHQ+PC9nPjwvc3ZnPg=="></p>
<p>For those of us not well-versed in the nitty-gritty of Linux network
programming, <code>tun0</code> jumps out the most and might come off as
an arcane term. Here <code>tun0</code> is the designation for a virtual
network interface within your Linux system. This isn’t a physical
network card that you can touch but a software-created interface that
acts and quacks like a real network device.</p>
<p>The term <code>tun/tap</code> refers to two virtual network device
drivers that are part of the Linux kernel. <code>tun</code> stands for
“network TUNnel” and is used to simulate a network layer device, while
<code>tap</code> stands for “network tap” and simulates a link layer
device. In essence, they are virtual network kernels that behave like
real network devices from the point of view of your operating system. <a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt">Reference
material</a>. I learned about it through Jon Gjengset (jonhoo)’s
excellent <a href="https://www.youtube.com/watch?v=bzja9fQWzdA">Implementing TCP in
Rust</a> stream, which covers <code>tun/tap</code> more succinctly and
in-depth.</p>
<p>I can attempt to dive deeper into this, but what clicked for me was
to jump straight into the code, so let’s do that here as well. We’ll be
leveraging the <a href="https://crates.io/crates/tun-tap"><code>tun-tap</code></a> crate
for this task. Borrowing from the <a href="https://github.com/vorner/tuntap/blob/master/examples/dump_iface.rs">example
code</a> provided by the crate:</p>
<div class="highlight"><pre><span></span><span class="c1">// Create the tun interface.</span>

<span class="kd">let</span><span class="w"> </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Iface</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;testtun&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Mode</span>::<span class="n">Tun</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;Iface: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iface</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Configure the „local“ (kernel) endpoint.</span>

<span class="n">cmd</span><span class="p">(</span><span class="s">&quot;ip&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="s">&quot;addr&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;add&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dev&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iface</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;10.107.1.2/24&quot;</span><span class="p">]);</span><span class="w"></span>

<span class="n">cmd</span><span class="p">(</span><span class="s">&quot;ip&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="s">&quot;link&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;set&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;up&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dev&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iface</span><span class="p">.</span><span class="n">name</span><span class="p">()]);</span><span class="w"></span>
</pre></div>
<p>The snippet above spins up a <code>tun</code> interface named
“testtun”. It then uses system commands to assign an IP address and
activates the interface.</p>
<div class="highlight"><pre><span></span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;You can for example ping 10.107.1.3 (it won&#39;t answer)&quot;</span><span class="p">);</span><span class="w"></span>



<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">1504</span><span class="p">];</span><span class="w"></span>

<span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Every read is one packet. If the buffer is too small, bad luck, it gets truncated.</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iface</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Packet: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="n">size</span><span class="p">]);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The <code>testtun</code> can be interacted with just like a typical
network interface, such as <code>eth0</code>. Pinging
<code>10.107.1.3</code> will dispatch ICMP packets, which our program
can intercept using <code>iface.recv</code>. Similarly, if there’s a
service listening on <code>10.107.1.2</code>—let’s say an HTTP server on
port <code>80</code>—sending a properly crafted IP packet to
<code>10.107.1.2:80</code> will be correctly routed to the service.</p>
<p>If you’re familiar with VPNs like <code>wireguard</code>, the
<code>wg0</code> interface that <code>wg-quick</code> conjures up is
actually a <code>tun</code> interface.</p>
<p>Now that we’re equipped to capture raw IP packets from
<code>tun0</code>, which are merely bytes, our next move is to wrap
these bytes in a custom VPN protocol, packaging each into a UDP
datagram. Initially, our encapsulation approach is straightforward: we
simply forward the IP packets without alteration, directly to the
server. On the wire, the IP packet structure resembles:</p>
<pre><code>+---------------------------------------+                    
|    +---------------------------------+|                    
|    |     +--------------------------+||                    
| IP |UDP  |IP                        |||                    
|    |     +--------------------------+||                    
|    +---------------------------------+|                    
+---------------------------------------+ </code></pre>
<p>Adding this entails an extra 28 bytes of overhead due to the IP and
UDP headers. If the route from client to server has an MTU (Maximum
Transmission Unit) of 1500 bytes—a common default—trying to send an
original IP packet of 1500 bytes will cause fragmentation, which is
usually best avoided. To tackle this, we can set the <code>tun0</code>
interface’s MTU to a lower value, akin to <code>wireguard</code> which
defaults to 1420:</p>
<div class="highlight"><pre><span></span>ip link <span class="nb">set</span> dev tun0 mtu <span class="m">1472</span>
</pre></div>
<p>By doing so, we ensure that packets received from <code>tun0</code>
will be at most 1472 bytes, thus avoiding fragmentation.</p>
<p>The reverse happens on the server: incoming UDP datagrams are
unwrapped, the original IP packets are written to the <code>tun0</code>
interface on the server by calling <code>iface.send</code>.</p>
</div>
<div id="basic-types" class="section level3">
<h3>Basic Types</h3>
<p>Now, we roll up our sleeves and start coding. First off, we’ll lay
out our starter types:</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="p">{</span><span class="n">SocketAddrV4</span><span class="p">,</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">};</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">tun_tap</span>::<span class="n">Iface</span><span class="p">;</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">parking_lot</span>::<span class="n">Mutex</span><span class="p">;</span><span class="w"></span>



<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">endpoint</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">SocketAddrV4</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">udp</span>: <span class="nc">UdpSocket</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">iface</span>: <span class="nc">Iface</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">peer</span>: <span class="nc">Peer</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>We’ll be utilizing our friend <code>Iface</code> from the
<code>tun-tap</code> crate, which, as we’ve discussed, represents a
virtual network interface. The <code>Device</code> struct is our central
entity for managing IP traffic tunneling. Unlike <code>wireguard</code>,
which permits defining multiple peers per host and supports complex
network configurations, our model will be more straightforward, with one
peer per host.</p>
<p>A <code>Peer</code> for now is just a wrapper around its endpoint,
which is an <code>Option&lt;SocketAddrV4&gt;</code> (we will be
supporting IPv4 only). The address is also wrapped in a
<code>Mutex</code> - this is a hint that we will be running this
application in multiple threads.</p>
<p>To explain why <code>endpoint</code> is an <code>Option</code>, on
the server side, our VPN application boots up without knowledge of its
peer’s IP address. This mirrors common real-world VPN scenarios where
the server has a known public IP, but the client IPs, often home
computers, are dynamically assigned by ISPs and not static.
Consequently, clients must initiate the contact. When the server
receives incoming connection attempts from clients (in our minimal
setup, a single client), it responds and decides whether to authorize or
reject these connections. Only after this handshake does a steady state
emerge, with both the client and server aware of each other’s addresses,
allowing for the free flow of data packets.</p>
</div>
<div id="two-main-loops" class="section level3">
<h3>Two main loops</h3>
<p>The core logic of our application revolves around two essential
loops:</p>
<ol style="list-style-type: decimal">
<li>The first loop listens for packets from the <code>iface</code> and
forwards them to the <code>peer</code> using the associated
<code>UdpSocket</code>.</li>
<li>The second loop listens on the <code>UdpSocket</code> for incoming
packets and forwards them to the <code>iface</code>.</li>
</ol>
<p>These loops are the heartbeats of our VPN tunnel, handling the
bidirectional flow of data:</p>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">loop_listen_iface</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// a large enough buffer, recall the MTU on iface was to be set to 1472</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1504</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">nbytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">peer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">();</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">peer_addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">],</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;..no peer&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The loop listening on the <code>iface</code> is straightforward: we
read packets from the virtual interface and forward them to the peer’s
address if it’s known. If we don’t have a peer address, it’s logged for
troubleshooting.</p>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">loop_listen_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1504</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">nbytes</span><span class="p">,</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer_addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">set_endpoint</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The listening loop on the <code>udp</code> socket has a nuanced role.
Whenever a packet is received, the sender’s address
(<code>peer_addr</code>) is captured. This address is crucial as it
determines where to send the reply packets. Using the
<code>set_endpoint</code> method, we update the peer’s endpoint only if
it hasn’t been set before. This allows the server to dynamically learn
about its client’s address, reflecting the typical behavior of a VPN
server where clients may have dynamic IP addresses. The implementation
of <code>set_endpoint</code> included below.</p>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">endpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MutexGuard</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">SocketAddrV4</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">endpoint</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">fn</span> <span class="nf">set_endpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span>: <span class="nc">SocketAddrV4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">endpoint</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">is_none</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="o">*</span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In the networking kingdom, our server mimics a hatchling imprinting
on the first creature it sees, treating the first IP address that comes
knocking as its trusted source. It’s a charming “love at first packet”
approach.</p>
<p>However, this method lacks discretion, much like a gosling mistaking
a bouncing ball for its parent. To prevent our server from naively
trusting any stray data packet that wanders by, we’ll need to implement
a handshake protocol… by requesting the client to say
<code>hello?</code> first:</p>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">loop_listen_iface</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// a large enough buffer, recall the MTU on iface was to be set to 1472</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1504</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">peer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">();</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">peer_addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;initiating </span><span class="se">\&quot;</span><span class="s">handshake</span><span class="se">\&quot;</span><span class="s"> to peer: {peer_addr}&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="s">&quot;hello?&quot;</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(),</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="c1">// omitted</span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">loop_listen_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1504</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">nbytes</span><span class="p">,</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer_addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">b&quot;hello?&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">handshake</span><span class="se">\&quot;</span><span class="s"> received&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">set_endpoint</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div id="put-it-all-together" class="section level3">
<h3>Put it All Together</h3>
<p>Behold, our <code>main.rs</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Parser)]</span><span class="w"></span>

<span class="cp">#[clap(author, version, about, long_about = None)]</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Cli</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[arg(long)]</span><span class="w"></span>

<span class="w">    </span><span class="n">peer</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">peer_addr</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tun_tap</span>::<span class="n">Iface</span>::<span class="n">without_packet_info</span><span class="p">(</span><span class="s">&quot;tun0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tun_tap</span>::<span class="n">Mode</span>::<span class="n">Tun</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">peer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer_addr</span><span class="w"></span>

<span class="w">        </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">addr</span><span class="o">|</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">SocketAddr</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ok</span><span class="p">())</span><span class="w"></span>

<span class="w">        </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">addr</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="nb">None</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">});</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Device</span>::<span class="n">new</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span><span class="w"> </span><span class="n">peer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev1</span><span class="p">);</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">jh1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev1</span><span class="p">.</span><span class="n">loop_listen_iface</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;err loop 1: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">jh2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev2</span><span class="p">.</span><span class="n">loop_listen_udp</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;err loop 2: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">});</span><span class="w"></span>



<span class="w">    </span><span class="n">jh1</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">jh2</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Start!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cli</span>::<span class="n">parse</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">run</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">as_deref</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The code above sets up a virtual network interface <code>tun0</code>
and parses the command-line arguments to determine if the program should
run in client mode (with a peer) or server mode (without a peer). Two
threads are spawned: one to manage data received from the virtual
interface, and another to handle incoming UDP packets. Error handling is
in place to log any issues encountered during execution.</p>
<p>For the grand finale, we roll out the red carpet with a pair of bash
scripts:</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>



<span class="c1"># This is run_client.sh</span>



sudo setcap <span class="nv">cap_net_admin</span><span class="o">=</span>eip target/release/wontun

target/release/wontun --peer <span class="m">172</span>.18.0.2:19988 <span class="p">&amp;</span>

<span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>



sudo ip addr add <span class="m">10</span>.8.0.3/24 dev tun0

sudo ip link <span class="nb">set</span> up dev tun0

sudo ip link <span class="nb">set</span> dev tun0 mtu <span class="m">1400</span>



<span class="nb">trap</span> <span class="s2">&quot;kill </span><span class="nv">$pid</span><span class="s2">&quot;</span> INT TERM

<span class="nb">wait</span> <span class="nv">$pid</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>



<span class="c1"># This is run_server.sh</span>



setcap <span class="s1">&#39;cap_net_admin=eip&#39;</span>  ./wontun



./wontun <span class="p">&amp;</span>

<span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>



ip addr add <span class="m">10</span>.8.0.1/24 dev tun0

ip link <span class="nb">set</span> up dev tun0

ip link <span class="nb">set</span> dev tun0 mtu <span class="m">1400</span>





<span class="nb">trap</span> <span class="s2">&quot;kill </span><span class="nv">$pid</span><span class="s2">&quot;</span> INT TERM



<span class="nb">wait</span> <span class="nv">$pid</span>
</pre></div>
<p>These scripts are the glue that binds our code to the system, setting
the required <code>cap_net_admin</code> capability which is necessary
for manipulating <code>tun</code> interfaces. The server script kicks
off <code>wontun</code> without specifying a peer, making it ready to
accept any incoming client. In contrast, the client script tells
<code>wontun</code> exactly where to find its server peer, in this case
at <code>172.18.0.2:19988</code>. Both scripts prepare the
<code>tun0</code> interface with appropriate IP configurations, client
at <code>10.8.0.3</code> and the server at <code>10.8.0.1</code>.</p>
<p>Final note, running <code>run_server.sh</code> inside docker operates
in a more restrictive environment. We need to explicitly pass the
<code>--cap-add=NET_ADMIN</code> and <code>--device=/dev/net/tun</code>
flags to enable <code>tun</code> interfaces inside the container:</p>
<div class="highlight"><pre><span></span>docker run --name wontun-remote <span class="se">\</span>

  --rm --network<span class="o">=</span>wontun-test --cap-add<span class="o">=</span>NET_ADMIN <span class="se">\</span>

  --device<span class="o">=</span>/dev/net/tun wontun-remote:latest
</pre></div>
<p>Now running the commands provided in the beginning of this section,
we can make the machines talk to each other over our makeshift, horribly
insecure VPN!</p>
<div class="highlight"><pre><span></span>root@2b97a5406ec2:/# nc -l <span class="m">10</span>.8.0.1 <span class="m">80</span>

Hello?

World!



host&gt; nc <span class="m">10</span>.8.0.1 <span class="m">80</span>

Hello?

World!
</pre></div>
<p>A checkpoint of <code>wontun</code> can be browsed at: <a href="https://github.com/yiransheng/wontun/tree/608ef9b71be486398bfca1662926fdc80a7d2901">Github
link</a></p>
</div>
</div>
<div id="lets-epoll" class="section level2">
<h2>Let’s Epoll</h2>
<p>With a proof of concept implemented, we are now ready to move on for
some architecture improvements. Our end goal is to support a multitude
of peers and intricate routing mechanisms (like <code>wireguard</code>).
To accomplish that, the VPN application likely needs to manage an
unbounded set of UDP connections (there will still be only one
<code>tun</code> interface however). The current implementation,
spawning two threads per peer, is charmingly simple but, let’s face it,
not quite fit for the big leagues in terms of scalability. Enter
<code>epoll</code> and non-blocking IO—our tools of choice for the next
phase. We will not be changing the application’s behavior just yet,
instead our goal is to replace the two main loops with a single
<code>epoll</code> backed event loop.</p>
<div id="quick-preview" class="section level3">
<h3>Quick Preview</h3>
<p>We will cover the following topics in this section:</p>
<ul>
<li>How <code>epoll</code> works and how to use it</li>
<li>More about the capacities and behaviors of <code>UdpSocket</code>,
particularly <code>SO_REUSEADDR</code> / port reuse</li>
<li>Some preparations to make our central <code>Device</code> type
thread safe, but the main loop will remain single-threaded for now</li>
</ul>
<p>Here’s a sneak peek at what our new and improved main loop will look
like:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ThreadData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">src_buf</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">],</span><span class="w"></span>

<span class="w">    </span><span class="p">};</span><span class="w"></span>



<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">Token</span>::<span class="n">Tun</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_tun</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;tun error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">Disconnected</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;udp error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">ConnectedPeer</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">().</span><span class="n">conn</span><span class="p">.</span><span class="n">as_deref</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_connected_peer</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;udp error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Without supplying to you further details, a few key observations:</p>
<ul>
<li>This code is modeled after <a href="https://crates.io/crates/mio"><code>mio</code></a> apis</li>
<li>The <code>match</code> is exhaustive, vaguely indicating we are
managing three file descriptors, based on naming: a <code>tun</code>
interface, a pair of connected and disconnected UDP sockets</li>
<li>The name <code>ThreadData</code> foreshadows our intention to run
this <code>wait</code> loop in multiple threads concurrently</li>
</ul>
</div>
<div id="epoll-basics" class="section level3">
<h3>Epoll Basics</h3>
<p><code>epoll</code> is an IO event notification facility in Linux,
designed to efficiently monitor multiple file descriptors. It’s
especially useful in applications where you need to handle numerous
simultaneous socket connections.</p>
<p>At its core, <code>epoll</code> operates using three main system
calls:</p>
<ol style="list-style-type: decimal">
<li><strong>epoll_create</strong>: This call creates an
<code>epoll</code> instance and returns a file descriptor associated
with it. This descriptor is used in subsequent <code>epoll</code> calls
and should be closed with <code>close()</code> when no longer
needed.</li>
<li><strong>epoll_ctl</strong>: This is used to add, modify, or remove
file descriptors from the <code>epoll</code> instance. It’s through this
call that you specify the events you are interested in for each file
descriptor. For instance, you might want to know when data is ready to
be read (<code>EPOLLIN</code>).</li>
<li><strong>epoll_wait</strong>: This call waits for events on the
<code>epoll</code> file descriptor. When an event occurs,
<code>epoll_wait</code> returns, providing information about the event
and the associated file descriptor.</li>
</ol>
<p>The <code>epoll</code> <a href="//%20https://man7.org/linux/man-pages/man7/epoll.7.html">man
page</a> is fairly comprehensive and relatively easy to follow, please
give it a read.</p>
</div>
<div id="understanding-epoll_event" class="section level3">
<h3>Understanding <code>epoll_event</code></h3>
<p>In applications using <code>epoll</code>, a central event loop
continuously calls <code>epoll_wait</code> to monitor for events. When
an event occurs, such as a <code>UdpSocket</code> becoming readable, the
application executes relevant non-blocking IO operations on the
corresponding file descriptor.</p>
<p>The event data in <code>epoll</code> is encapsulated in a
<code>struct epoll_event</code>, which contains two key pieces of
information:</p>
<ol style="list-style-type: decimal">
<li><strong>epoll_event.event</strong>: This field holds the
<code>epoll</code> flags, which signal the type of event. Common flags
include <code>EPOLLIN</code> for readability and <code>EPOLLOUT</code>
for writability of a file descriptor.</li>
<li><strong>epoll_event.data</strong>: This is a user-defined
<code>u64</code> value, set during the <code>epoll_ctl</code> call and
returned by <code>epoll_wait</code>. It helps the application identify
which file descriptor or resource the event is associated with.</li>
</ol>
</div>
<div id="handling-callbacks-in-rust" class="section level3">
<h3>Handling Callbacks in Rust</h3>
<p>Traditionally, in languages like C, the <code>epoll_event.data</code>
is often used to store a pointer to a callback function that should be
executed in response to the event. However, in Rust, this approach would
require unsafe code to cast a <code>Box&lt;dyn FnMut(_)&gt;</code> to
and from a <code>u64</code>, which can be risky and complex.</p>
<p>To avoid unsafe code, our <code>wontun</code> application will
utilize a tailor-made <code>Token</code> type that can be safely encoded
into and decoded from a <code>u64</code>. This <code>Token</code> will
help us identify which socket has become active and determine the
appropriate handler function to execute. This approach avoids
<code>unsafe</code> code while providing the flexibility needed for
event handling.</p>
<p>Finally, for sending data through <code>UdpSocket</code> and
<code>Iface</code>, it’s worth noting that these operations are
generally non-blocking. To keep our implementation straightforward, we
will register only read interests (<code>EPOLLIN</code>) with
<code>epoll</code>. Consequently, data sending will occur directly
within the read handlers, simplifying the logic and avoiding the need
for managing writable state or additional <code>epoll</code> flags for
output operations. This choice helps streamline the event handling
process, focusing on efficiently managing incoming data and responding
promptly.</p>
</div>
<div id="the-poll-wrapper" class="section level3">
<h3>The <code>Poll</code> Wrapper</h3>
<p>We introduce the <code>Poll</code> wrapper, a crucial component for
managing <code>epoll</code> interactions more effectively. We utilize
the <code>nix</code> crate, which provides a safe interface to the
underlying <code>epoll</code> system calls in Linux. The wrapper we
build around <code>nix::sys::epoll::Epoll</code> is designed to simplify
our interactions with <code>epoll</code>.</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">os</span>::<span class="n">fd</span>::<span class="n">AsFd</span><span class="p">;</span><span class="w"></span>



<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">epoll</span>::<span class="p">{</span><span class="n">Epoll</span><span class="p">,</span><span class="w"> </span><span class="n">EpollCreateFlags</span><span class="p">,</span><span class="w"> </span><span class="n">EpollEvent</span><span class="p">,</span><span class="w"> </span><span class="n">EpollFlags</span><span class="p">};</span><span class="w"></span>



<span class="cp">#[derive(Debug, Copy, Clone, Eq, PartialEq)]</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">Tun</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">Sock</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="cp">#[derive(Debug, Copy, Clone, Eq, PartialEq)]</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">UnknownToken</span><span class="p">;</span><span class="w"></span>



<span class="k">impl</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u64</span><span class="w"></span>

<span class="k">where</span><span class="w"></span>

<span class="w">    </span><span class="n">ID</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span>: <span class="nc">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">Token</span>::<span class="n">Tun</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">sock_index</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">sock_index</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">impl</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"></span>

<span class="k">where</span><span class="w"></span>

<span class="w">    </span><span class="n">ID</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnknownToken</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Tun</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">((</span><span class="n">value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">).</span><span class="n">into</span><span class="p">()),</span><span class="w"></span>

<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">UnknownToken</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">const</span><span class="w"> </span><span class="n">EPOLL_FLAGS</span>: <span class="nc">EpollFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EpollFlags</span>::<span class="n">EPOLLIN</span><span class="p">.</span><span class="k">union</span><span class="p">(</span><span class="n">EpollFlags</span>::<span class="n">EPOLLET</span><span class="p">);</span><span class="w"></span>



<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Poll</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">epoll</span>: <span class="nc">Epoll</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">impl</span><span class="w"> </span><span class="n">Poll</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">epoll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Epoll</span>::<span class="n">new</span><span class="p">(</span><span class="n">EpollCreateFlags</span>::<span class="n">EPOLL_CLOEXEC</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">epoll</span><span class="w"> </span><span class="p">})</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">register_read</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nc">AsFd</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">token</span>: <span class="nc">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">fd</span>: <span class="kp">&amp;</span><span class="nc">F</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EpollEvent</span>::<span class="n">new</span><span class="p">(</span><span class="n">EPOLL_FLAGS</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">into</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">epoll</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">delete</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nc">AsFd</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span>: <span class="kp">&amp;</span><span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">epoll</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wait</span><span class="o">&lt;</span><span class="n">ID</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">EpollEvent</span>::<span class="n">empty</span><span class="p">()];</span><span class="w"></span>



<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">epoll</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>



<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span>::<span class="n">try_from</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unexpected epoll data&quot;</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>As you can tell, there isn’t all that much going on. We just wrap the
original <code>new</code>, <code>add</code>, <code>delete</code> and
<code>wait</code> methods with trivial type conversions added. The small
customizations are:</p>
<ul>
<li>In <code>wait</code>, wait for one event at a time
(<code>epoll_wait</code> sys call can return a list of ready events
using the out parameter pattern through the<code>&amp;mut events</code>
argument)</li>
<li>Use a <code>Token</code> type for event identification as explained
previously</li>
</ul>
</div>
<div id="revised-device-type" class="section level3">
<h3>Revised <code>Device</code> Type</h3>
<p>It’s time for the core types from the first section to get an
upgrade:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">udp</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">UdpSocket</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">iface</span>: <span class="nc">Iface</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">peer</span>: <span class="nc">Peer</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">poll</span>: <span class="nc">Poll</span><span class="p">,</span><span class="w"></span>



<span class="w">    </span><span class="n">use_connected_peer</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">listen_port</span>: <span class="kt">u16</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">endpoint</span>: <span class="nc">RwLock</span><span class="o">&lt;</span><span class="n">Endpoint</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="cp">#[derive(Default)]</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Endpoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">addr</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SocketAddrV4</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">conn</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">UdpSocket</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Some key changes:</p>
<ol style="list-style-type: decimal">
<li><strong>Incorporating <code>Poll</code></strong>: The
<code>Device</code> now includes a <code>Poll</code> instance, allowing
it to interact efficiently with the <code>epoll</code> mechanism.</li>
<li><strong>Enhanced Endpoint Type</strong>: Previously, an endpoint was
simply represented as an <code>Option&lt;SocketAddrV4&gt;</code>. Now,
it’s a full-fledged <code>Endpoint</code> struct, accommodating an
additional field
<code>conn: Option&lt;Arc&lt;UdpSocket&gt;&gt;</code>.</li>
<li><strong>Use of Arc and RwLock</strong>: The introduction of
<code>Arc</code> (Atomic Reference Counting) and <code>RwLock</code>
(Read-Write Lock) indicates a shift towards thread-safe operations.</li>
</ol>
<p>The big picture idea is the concept of using a “connected peer”. This
applies to <code>wontun</code> on the server side. Previously, we used a
single <code>UdpSocket</code> for receiving and sending data, this is
possible because <code>UdpSocket</code>s are connectionless. Now, once a
client peer connects to the server, we shall open a new
<code>UdpSocket</code> and connect it to the client’s (public) IP
address and port.</p>
<p>In networking, UDP sockets can operate in two modes: connected and
disconnected (or bind-only).</p>
<ul>
<li><strong>Disconnected/Bind-Only UDP Sockets</strong>: These are the
traditional form of UDP sockets. They are not connected to a specific
remote address. Instead, each IO operation on the socket requires
specifying the target address for sending data. This mode is flexible as
it allows a single socket to communicate with multiple peers, but it
requires the application to manage the mapping between messages and
their destinations or sources.</li>
<li><strong>Connected UDP Sockets</strong>: When a UDP socket is
“connected” to a specific remote address and port, it can <strong>only
send to and receive from that particular address</strong>. This
restriction simplifies the IO operations since the target/source address
need not be specified with each operation. For <code>wontun</code> on
the server side, this approach means that once a client establishes a
connection, the server opens a new, dedicated UDP socket connected to
the client’s public IP and port. This setup streamlines communication
with individual clients, once we start introducing more peers into the
system, this setup would greatly simply state management and packet
routing.</li>
</ul>
<p>In conclusion, now for each <code>Device</code> instance, there will
be three IO resources in the loop: the <code>tun</code> interface, a
disconnected <code>UdpSocket</code> to handle the initial client
handshake, and a connected peer <code>UdpSocket</code> to transmit
subsequent data packets over.</p>
</div>
<div id="port-reuse" class="section level3">
<h3>Port Reuse</h3>
<p>With the introduction of a second <code>UdpSocket</code> in our
system, we encounter a challenge: we have only one port available for
listening. Attempting to bind another <code>UdpSocket</code> to this
same port would normally result in an <code>EADDRINUSE</code> IO error.
A solution exists in the form of port reuse, enabled by the
<code>SO_REUSEADDR</code> socket option.</p>
<p><code>SO_REUSEADDR</code> is a socket option that influences how the
underlying operating system manages socket bindings, particularly
regarding address and port reuse. System Calls Associated with
<code>SO_REUSEADDR</code>:</p>
<ol style="list-style-type: decimal">
<li><strong>setsockopt</strong>: This is the primary system call used to
enable the <code>SO_REUSEADDR</code> option on a socket. It’s used to
set options at the socket level and is called after socket creation but
before binding the socket to an address with <code>bind</code>.</li>
<li><strong>bind</strong>: This system call assigns a local protocol
address to a socket. With <code>SO_REUSEADDR</code> enabled, the
<code>bind</code> call allows a new socket to be bound to a port already
in use by another socket.</li>
</ol>
<p>The standard Rust <code>UdpSocket</code> library doesn’t directly
support <code>SO_REUSEADDR</code>, so we turn to the <a href="https://crates.io/crates/socket2"><code>socket2</code></a> crate
for this functionality. Here’s how it’s done:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">new_udp_socket</span><span class="p">(</span><span class="n">port</span>: <span class="kt">u16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">UdpSocket</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">socket_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">from</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">port</span><span class="p">));</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Socket</span>::<span class="n">new</span><span class="p">(</span><span class="n">Domain</span>::<span class="n">IPV4</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span>::<span class="n">DGRAM</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Protocol</span>::<span class="n">UDP</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="n">socket</span><span class="p">.</span><span class="n">set_reuse_address</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">socket</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="n">socket</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">socket_addr</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>



<span class="k">impl</span><span class="w"> </span><span class="n">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">connect_endpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">port</span>: <span class="kt">u16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">UdpSocket</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">endpoint</span><span class="p">.</span><span class="n">write</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>



<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">endpoint</span><span class="p">.</span><span class="n">conn</span><span class="p">.</span><span class="n">is_none</span><span class="p">());</span><span class="w"></span>



<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_udp_socket</span><span class="p">(</span><span class="n">port</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">conn</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span><span class="w"></span>



<span class="w">        </span><span class="n">endpoint</span><span class="p">.</span><span class="n">conn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="p">));</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Note there’s a modern alternative to <code>SO_REUSEADDR</code> in
Linux kernel &gt;=3.9 that is <code>SO_REUSEPORT</code>, which does a
bit more magic:</p>
<blockquote>
<p>For UDP sockets, it tries to distribute datagrams evenly, for TCP
listening sockets, it tries to distribute incoming connect requests
(those accepted by calling <code>accept()</code>) evenly across all the
sockets that share the same address and port combination.</p>
</blockquote>
<p>Source: <a href="https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ" class="uri">https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ</a></p>
<p>The <code>socket2</code>’s <code>set_reuse_address</code> api
supports <code>SO_REUSEADDR</code> only. If desired, we can invoke
<code>setsockopt</code> sys call on the <code>socket2::Socket</code>’s
file descriptor directly. For now <code>SO_REUSEADDR</code> will do, we
just need to make sure our handlers for either <code>UdpSocket</code>
can handle incoming datagrams correctly.</p>
</div>
<div id="the-startup-and-the-handlers" class="section level3">
<h3>The Startup and the Handlers</h3>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="w"></span>

<span class="w">        </span><span class="p">.</span><span class="n">register_read</span><span class="p">(</span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">Disconnected</span><span class="p">),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">as_ref</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tun_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">BorrowedFd</span>::<span class="n">borrow_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">())</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="p">.</span><span class="n">register_read</span>::<span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">SockID</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Token</span>::<span class="n">Tun</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tun_fd</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">initiate_handshake</span><span class="p">()</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Upon initialization, the <code>Device</code> is configured with a
listening <code>UdpSocket</code> (<code>self.udp</code>) and a
<code>tun</code> interface (<code>self.iface</code>). Both of these are
registered with the <code>epoll</code> instance (<code>self.poll</code>)
to monitor for readable events. This setup ensures that our application
is immediately ready to handle incoming data on both the
<code>tun</code> interface and the UDP socket.</p>
<p>The handler for reading from <code>self.iface</code> is similar to
the code we had at POC stage (it is helpful to refer back to the <a href="#quick-preview">event loop</a> shown earlier for details on how we
call this handler):</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">handle_tun</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">thread_data</span><span class="p">.</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ignore send errors</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_send_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">conn</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">conn</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">])</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">],</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>If our peer is connected, we prefer to send data over the connected
<code>UdpSocket</code>. Otherwise, we will use the main listening socket
<code>self.udp</code> and a <code>send_to</code> call.</p>
<p>Handling incoming data from a connected peer’s <code>UdpSocket</code>
is also straightforward:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">handle_connected_peer</span><span class="p">(</span><span class="w"></span>

<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">sock</span>: <span class="kp">&amp;</span><span class="nc">UdpSocket</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">,</span><span class="w"></span>

<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">thread_data</span><span class="p">.</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Handling incoming data from the default, disconnected socket is a bit
more involved:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">handle_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">sock</span>: <span class="kp">&amp;</span><span class="nc">UdpSocket</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">thread_data</span><span class="p">.</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">((</span><span class="n">nbytes</span><span class="p">,</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer_addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">b&quot;hello?&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;received handshake..&quot;</span><span class="p">);</span><span class="w"></span>



<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">endpoint_changed</span><span class="p">,</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">set_endpoint</span><span class="p">(</span><span class="n">peer_addr_v4</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()).</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;epoll delete&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="nb">drop</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>



<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">endpoint_changed</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">use_connected_peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">connect_endpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">listen_port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                            </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="w"></span>

<span class="w">                            </span><span class="p">.</span><span class="n">register_read</span><span class="p">(</span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">ConnectedPeer</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">conn</span><span class="p">)</span><span class="w"></span>

<span class="w">                            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;epoll add&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">                        </span><span class="p">}</span><span class="w"></span>

<span class="w">                        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;error connecting to peer: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                        </span><span class="p">}</span><span class="w"></span>

<span class="w">                    </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The primary task here is to manage the handshake process, marked by a
simple “hello?” message. The function retrieves the client’s IP address
and updates the peer endpoint accordingly. If the application is
configured to use a connected socket
(<code>self.use_connected_peer</code>), it establishes a new connected
<code>UdpSocket</code> for the peer, enhancing the efficiency of the
communication channel. Key points:</p>
<ul>
<li>The <code>recv_from</code> call captures the client’s address
(<code>peer_addr_v4</code>), enabling the server to respond
appropriately.</li>
<li>Next, the call to <code>self.peer.set_endpoint</code> update’s the
peer endpoint address, and returns if it had a different address and a
previous connected <code>UdpSocket</code> is any.
<ul>
<li>This is the reason we introduced a <code>RwLock</code> in
<code>Peer.endpoint</code>, we need write access to
<code>&amp;self.peer</code> here, accommodating dynamic changes in the
connected client’s address.</li>
<li>If a prior <code>endpoint.conn</code> exists, we remove it from the
<code>epoll</code> set and <code>drop</code> it.</li>
</ul></li>
<li>If the device is configured to use connected socket
(<code>self.use_connected_peer</code>), we create a connected
<code>UdpSocket</code> (returned from <code>peer.connect_endpoint</code>
call), reusing the same listening port configured on the device.
<ul>
<li>And we add this newly created <code>UdpSocket</code> to
<code>self.epoll</code> set.</li>
<li>Note we use a <code>Token::Sock(SockID::ConnectedPeer)</code> to
register the read interest, to distinguish from the
<code>Token::Sock(SockID::Disconnected)</code> for the default listening
<code>UdpSocket</code> registered in startup code (<code>start</code>
method).</li>
</ul></li>
</ul>
</div>
<div id="thats-all-and-the-final-code" class="section level3">
<h3>That’s all and the Final Code</h3>
<div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span>: <span class="nc">DeviceConfig</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ... omitted</span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ThreadData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">src_buf</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>



<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">poll</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="n">Token</span>::<span class="n">Tun</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_tun</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;tun error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">Disconnected</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;udp error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="n">Token</span>::<span class="n">Sock</span><span class="p">(</span><span class="n">SockID</span>::<span class="n">ConnectedPeer</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">().</span><span class="n">conn</span><span class="p">.</span><span class="n">as_deref</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_connected_peer</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&quot;udp error: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>

<span class="w">                        </span><span class="p">}</span><span class="w"></span>

<span class="w">                    </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// omitted...</span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">handle_tun</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// omitted...</span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">fn</span> <span class="nf">handle_connected_peer</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">sock</span>: <span class="kp">&amp;</span><span class="nc">UdpSocket</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// omitted...</span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">handle_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">sock</span>: <span class="kp">&amp;</span><span class="nc">UdpSocket</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// omitted...</span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">initiate_handshake</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&quot;hello?&quot;</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">endpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peer</span><span class="p">.</span><span class="n">endpoint</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">conn</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">conn</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">udp</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>



<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">peer</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SocketAddrV4</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DeviceConfig</span>::<span class="n">new</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* use_connected_peer: */</span><span class="w"> </span><span class="n">peer</span><span class="p">.</span><span class="n">is_none</span><span class="p">(),</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* listen_port: */</span><span class="w"> </span><span class="mi">19988</span><span class="p">,</span><span class="w"> </span>

<span class="w">        </span><span class="cm">/* tun_name: */</span><span class="w"> </span><span class="s">&quot;tun0&quot;</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* peer_addr: */</span><span class="w"> </span><span class="n">peer</span><span class="w"></span>

<span class="w">    </span><span class="p">);</span><span class="w"></span>



<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Device</span>::<span class="n">new</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">dev</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">dev</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Use the same setup and shell scripts as <a href="#put-it-all-together">before</a>, we can verify things are still
in working condition. We have successfully refactored
<code>wontun</code> to use <code>epoll</code> and connected sockets. A
checkpoint of <code>wontun</code> can be browsed at: <a href="https://github.com/yiransheng/wontun/tree/a6a5306c4f91203713c52736f29caa474083a8fe">Github
link</a>.</p>
</div>
</div>
<div id="many-peers" class="section level2">
<h2>Many Peers</h2>
<div id="project-overview" class="section level3">
<h3>Project Overview</h3>
<p>A little bit of house keeping upfront. Up until this point, we have
been putting everything inside <code>lib.rs</code>. It’s time to factor
out various building blocks, roughly into their respective types and
purposes. This is the new file structure under <code>src</code>:</p>
<div class="highlight"><pre><span></span>src/

├── allowed_ip.rs

├── conf.rs

├── dev.rs

├── lib.rs

├── packet.rs

├── peer.rs

├── poll.rs

├── udp.rs

├── wontun-conf.rs

└── wontun.rs



0 directories, 10 files
</pre></div>
<ul>
<li><code>wontun.rs</code> is our main binary entry point.</li>
<li><code>wontun-conf.rs</code> is an auxiliary binary that parses
configuration files in <code>ini</code> format and dump them into
<code>json</code> (which then can be manipulated easily with
<code>jq</code> in shell scripts).</li>
<li><code>conf.rs</code> defines a configuration format and implements
parsing from <code>ini</code>. The supported options are a subset of
<code>wireguard</code> configurations format.</li>
<li><code>poll.rs</code> is our <code>Poll</code> wrapper from before,
and will remain unchanged in this section.</li>
<li><code>udp.rs</code> contains a single helper function
<code>new_udp_socket</code> from last section.</li>
<li><code>dev.rs</code> and <code>peer.rs</code> corresponds to our
familiar <code>Device</code> and <code>Peer</code> types, which of
course will be going through some changes.</li>
<li><code>packet.rs</code> and <code>allowed_ips.rs</code> are new
modules that will be covered in details soon.</li>
</ul>
</div>
<div id="peer-identities" class="section level3">
<h3>Peer Identities</h3>
<p>When the world contains all but two entities, there are no need for
names. The pronouns “you” and “me” are enough for the pair to refer to
each other. This was the situation when we restricted our VPN to allow
only one peer per host. On either machine, any bytes coming from the
<code>tun</code> interface was unambiguously meant for “you”, the
singular partner in our lonely VPN network.</p>
<p>As we invite more participants to our VPN party, a clear system of
identification becomes evident. <code>wireguard</code> identifies peers
by their <code>PublicKey</code>s, we will simply use string names -
shamelessly transmitted over the wire in plain texts.</p>
<p><strong>Configuration Examples</strong></p>
<p>Consider three hosts, <code>A</code>, <code>B</code>, and
<code>C</code>. Their configurations might look like this:</p>
<p>Configuration on <code>A</code>:</p>
<div class="highlight"><pre><span></span><span class="k">[Interface]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">A</span><span class="w"></span>



<span class="k">[Peer]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">B</span><span class="w"></span>



<span class="k">[Peer]</span><span class="w"></span>

<span class="na">...</span><span class="w"></span>
</pre></div>
<p>Configuration on <code>B</code>:</p>
<div class="highlight"><pre><span></span><span class="k">[Interface]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">B</span><span class="w"></span>



<span class="k">[Peer]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">C</span><span class="w"></span>



<span class="k">[Peer]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">A</span><span class="w"></span>
</pre></div>
<p>Configuration on <code>C</code>:</p>
<div class="highlight"><pre><span></span><span class="k">[Interface]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">C</span><span class="w"></span>



<span class="k">[Peer]</span><span class="w"></span>

<span class="na">Name</span><span class="o">=</span><span class="s">B</span><span class="w"></span>
</pre></div>
<p><strong>Interesting note</strong>: the <code>Name</code> field is
supported by <code>wireguard</code>, but ignored entirely, it exists
only as a form of documentation.</p>
<p>The names are global and all hosts agree on their meanings. If, for
example, each host stores a <code>HashMap&lt;PeerName, Peer&gt;</code>
at runtime, and every packet transmitted over UDP includes the name of
the sender, it would be fairly straightforward to route the packets.
However, including a potentially long name in every data packet
transmitted is just too wasteful, we opt to use a slightly more
complicated system, and tag each message with a <code>u32</code>
index.</p>
<p>Each host configures its peers and assigns a <code>local_index</code>
at startup, effectively placing each peer at a specific position in a
<code>Vec&lt;Peer&gt;</code>. But there’s a catch: peers initially don’t
know their <code>local_index</code> as seen by others. For instance,
host <code>B</code> might be <code>local_index=9</code> in
<code>A</code>’s list, but <code>B</code> itself starts unaware of this
numeric label.</p>
<p>For this reason, we shall store another index in
<code>struct Peer</code>, called <code>remote_index</code>. At the
steady state, the <code>Device</code> on node <code>B</code> would have
the following data:</p>
<div class="highlight"><pre><span></span><span class="n">Deivice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">name</span>: <span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">peers</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w"></span>

<span class="w">        </span><span class="n">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">name</span>: <span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="c1">// This peer is the 0&#39;th element in peers Vec</span>

<span class="w">            </span><span class="n">local_index</span>: <span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="n">remote_index</span>: <span class="mi">9</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">]</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>On node <code>A</code>:</p>
<div class="highlight"><pre><span></span><span class="n">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">name</span>: <span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">peers</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="w"></span>

<span class="w">        </span><span class="c1">//...</span>

<span class="w">        </span><span class="n">Peer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">name</span>: <span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="c1">// This peer is the 9&#39;th element in peers Vec</span>

<span class="w">            </span><span class="n">local_index</span>: <span class="mi">9</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="n">remote_index</span>: <span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">]</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This relationship between <code>local_index</code> and
<code>remote_index</code> is further clarified/illustrated below:</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDAuMSAoMjAxNjEyMjUuMDMwNCkKIC0tPjwhLS0gVGl0bGU6IEcgUGFnZXM6IDEgLS0+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjE4cHQiIGhlaWdodD0iMjY3cHQiIHZpZXdCb3g9IjAuMDAgMC4wMCA2MTguMDAgMjY3LjIwIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDEgMSkgcm90YXRlKDApIHRyYW5zbGF0ZSg0IDI2My4yKSI+Cjx0aXRsZT5HPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJ0cmFuc3BhcmVudCIgcG9pbnRzPSItNCw0IC00LC0yNjMuMiA2MTQsLTI2My4yIDYxNCw0IC00LDQiLz4KPGcgaWQ9ImNsdXN0MSIgY2xhc3M9ImNsdXN0ZXIiPgo8dGl0bGU+Y2x1c3Rlcl8wPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2QzZDNkMyIgc3Ryb2tlPSIjZDNkM2QzIiBwb2ludHM9IjgsLTEzMy42IDgsLTI1MS4yIDM0MCwtMjUxLjIgMzQwLC0xMzMuNiA4LC0xMzMuNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIxNzQiIHk9Ii0yMzQuNiIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5ub2RlLUE8L3RleHQ+CjwvZz4KPGcgaWQ9ImNsdXN0MiIgY2xhc3M9ImNsdXN0ZXIiPgo8dGl0bGU+Y2x1c3Rlcl8xPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2YwZjBlZSIgc3Ryb2tlPSIjZjBmMGVlIiBwb2ludHM9Ijk0LC0xNDEuNiA5NCwtMjE4LjQgMzMyLC0yMTguNCAzMzIsLTE0MS42IDk0LC0xNDEuNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIyMTMiIHk9Ii0yMDEuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5QZWVyIChuYW1lPUIpPC90ZXh0Pgo8L2c+CjxnIGlkPSJjbHVzdDMiIGNsYXNzPSJjbHVzdGVyIj4KPHRpdGxlPmNsdXN0ZXJfMTA8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSIjZjBmMGVlIiBzdHJva2U9IiNmMGYwZWUiIHBvaW50cz0iMTYsLTE0MS42IDE2LC0yMTguNCA4NiwtMjE4LjQgODYsLTE0MS42IDE2LC0xNDEuNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI1MSIgeT0iLTIwMS44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPnBlZXJzPC90ZXh0Pgo8L2c+CjxnIGlkPSJjbHVzdDQiIGNsYXNzPSJjbHVzdGVyIj4KPHRpdGxlPmNsdXN0ZXJfNTwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNkM2QzZDMiIHN0cm9rZT0iI2QzZDNkMyIgcG9pbnRzPSIzNDgsLTEzMy42IDM0OCwtMjUxLjIgNjAyLC0yNTEuMiA2MDIsLTEzMy42IDM0OCwtMTMzLjYiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iNDc1IiB5PSItMjM0LjYiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+bm9kZS1DPC90ZXh0Pgo8L2c+CjxnIGlkPSJjbHVzdDUiIGNsYXNzPSJjbHVzdGVyIj4KPHRpdGxlPmNsdXN0ZXJfNjwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNmMGYwZWUiIHN0cm9rZT0iI2YwZjBlZSIgcG9pbnRzPSIzNTYsLTE0MS42IDM1NiwtMjE4LjQgNTk0LC0yMTguNCA1OTQsLTE0MS42IDM1NiwtMTQxLjYiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iNDc1IiB5PSItMjAxLjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+UGVlciAobmFtZT1CKTwvdGV4dD4KPC9nPgo8ZyBpZD0iY2x1c3Q2IiBjbGFzcz0iY2x1c3RlciI+Cjx0aXRsZT5jbHVzdGVyXzI8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSIjZDNkM2QzIiBzdHJva2U9IiNkM2QzZDMiIHBvaW50cz0iOTcsLTggOTcsLTEyNS42IDU5NywtMTI1LjYgNTk3LC04IDk3LC04Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjM0NyIgeT0iLTEwOSIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5ub2RlLUI8L3RleHQ+CjwvZz4KPGcgaWQ9ImNsdXN0NyIgY2xhc3M9ImNsdXN0ZXIiPgo8dGl0bGU+Y2x1c3Rlcl8zPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2YwZjBlZSIgc3Ryb2tlPSIjZjBmMGVlIiBwb2ludHM9IjEwNSwtMTYgMTA1LC05Mi44IDM0MywtOTIuOCAzNDMsLTE2IDEwNSwtMTYiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMjI0IiB5PSItNzYuMiIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5QZWVyIChuYW1lPUEpPC90ZXh0Pgo8L2c+CjxnIGlkPSJjbHVzdDgiIGNsYXNzPSJjbHVzdGVyIj4KPHRpdGxlPmNsdXN0ZXJfNDwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNmMGYwZWUiIHN0cm9rZT0iI2YwZjBlZSIgcG9pbnRzPSIzNTEsLTE2IDM1MSwtOTIuOCA1ODksLTkyLjggNTg5LC0xNiAzNTEsLTE2Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjQ3MCIgeT0iLTc2LjIiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+UGVlciAobmFtZT1DKTwvdGV4dD4KPC9nPgo8IS0tIGFibCAtLT4KPGcgaWQ9ImFibCIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+YWJsPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZmZmZmZmIiBwb2ludHM9IjMyMy43MDY2LC0xODUuNiAyMjguMjkzNCwtMTg1LjYgMjI4LjI5MzQsLTE0OS42IDMyMy43MDY2LC0xNDkuNiAzMjMuNzA2NiwtMTg1LjYiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMjc2IiB5PSItMTYzLjQiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+bG9jYWxfaW5kZXg6IDk8L3RleHQ+CjwvZz4KPCEtLSBhYnIgLS0+CjxnIGlkPSJhYnIiIGNsYXNzPSJub2RlIj4KPHRpdGxlPmFicjwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2ZmZmZmZiIgcG9pbnRzPSIyMDkuODY3NCwtMTg1LjYgMTAyLjEzMjYsLTE4NS42IDEwMi4xMzI2LC0xNDkuNiAyMDkuODY3NCwtMTQ5LjYgMjA5Ljg2NzQsLTE4NS42Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjE1NiIgeT0iLTE2My40IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPnJlbW90ZV9pbmRleDogMTwvdGV4dD4KPC9nPgo8IS0tIGJhbCAtLT4KPGcgaWQ9ImJhbCIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+YmFsPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZmZmZmZmIiBwb2ludHM9IjIwOC43MDY2LC02MCAxMTMuMjkzNCwtNjAgMTEzLjI5MzQsLTI0IDIwOC43MDY2LC0yNCAyMDguNzA2NiwtNjAiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMTYxIiB5PSItMzcuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5sb2NhbF9pbmRleDogMTwvdGV4dD4KPC9nPgo8IS0tIGFiciYjNDU7Jmd0O2JhbCAtLT4KPGcgaWQ9ImVkZ2UxIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5hYnItJmd0O2JhbDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgZD0iTTE1Ni43MjcsLTE0OS4zMzY3QzE1Ny41NTI4LC0xMjguNTkzNCAxNTguOTEwMywtOTQuNDkzOCAxNTkuODczNCwtNzAuMyIvPgo8cG9seWdvbiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iMTYzLjM3MTQsLTcwLjQxNjcgMTYwLjI3MjEsLTYwLjI4NTQgMTU2LjM3NywtNzAuMTM4MiAxNjMuMzcxNCwtNzAuNDE2NyIvPgo8L2c+CjwhLS0gb3RoZXJzIC0tPgo8ZyBpZD0ibm9kZTMiIGNsYXNzPSJub2RlIj4KPHRpdGxlPm90aGVyczwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iI2ZmZmZmZiIgcG9pbnRzPSI3OCwtMTg1LjYgMjQsLTE4NS42IDI0LC0xNDkuNiA3OCwtMTQ5LjYgNzgsLTE4NS42Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjUxIiB5PSItMTYzLjQiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+Li4uPC90ZXh0Pgo8L2c+CjwhLS0gY2JsIC0tPgo8ZyBpZD0iY2JsIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5jYmw8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHBvaW50cz0iNTg1LjcwNjYsLTE4NS42IDQ5MC4yOTM0LC0xODUuNiA0OTAuMjkzNCwtMTQ5LjYgNTg1LjcwNjYsLTE0OS42IDU4NS43MDY2LC0xODUuNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI1MzgiIHk9Ii0xNjMuNCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5sb2NhbF9pbmRleDogMDwvdGV4dD4KPC9nPgo8IS0tIGNiciAtLT4KPGcgaWQ9ImNiciIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+Y2JyPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZmZmZmZmIiBwb2ludHM9IjQ3MS44Njc0LC0xODUuNiAzNjQuMTMyNiwtMTg1LjYgMzY0LjEzMjYsLTE0OS42IDQ3MS44Njc0LC0xNDkuNiA0NzEuODY3NCwtMTg1LjYiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iNDE4IiB5PSItMTYzLjQiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+cmVtb3RlX2luZGV4OiAwPC90ZXh0Pgo8L2c+CjwhLS0gYmNsIC0tPgo8ZyBpZD0iYmNsIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5iY2w8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHBvaW50cz0iNDU0LjcwNjYsLTYwIDM1OS4yOTM0LC02MCAzNTkuMjkzNCwtMjQgNDU0LjcwNjYsLTI0IDQ1NC43MDY2LC02MCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI0MDciIHk9Ii0zNy44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPmxvY2FsX2luZGV4OiAwPC90ZXh0Pgo8L2c+CjwhLS0gY2JyJiM0NTsmZ3Q7YmNsIC0tPgo8ZyBpZD0iZWRnZTIiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPmNici0mZ3Q7YmNsPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBkPSJNNDE2LjQwMDUsLTE0OS4zMzY3QzQxNC41ODM4LC0xMjguNTkzNCA0MTEuNTk3NCwtOTQuNDkzOCA0MDkuNDc4NSwtNzAuMyIvPgo8cG9seWdvbiBmaWxsPSIjMDAwMDAwIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iNDEyLjk2MDYsLTY5Ljk0MTggNDA4LjYwMTQsLTYwLjI4NTQgNDA1Ljk4NzMsLTcwLjU1MjYgNDEyLjk2MDYsLTY5Ljk0MTgiLz4KPC9nPgo8IS0tIGJhciAtLT4KPGcgaWQ9ImJhciIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+YmFyPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjZmZmZmZmIiBwb2ludHM9IjMzNC44Njc0LC02MCAyMjcuMTMyNiwtNjAgMjI3LjEzMjYsLTI0IDMzNC44Njc0LC0yNCAzMzQuODY3NCwtNjAiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMjgxIiB5PSItMzcuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5yZW1vdGVfaW5kZXg6IDk8L3RleHQ+CjwvZz4KPCEtLSBiYXImIzQ1OyZndDthYmwgLS0+CjxnIGlkPSJlZGdlMyIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+YmFyLSZndDthYmw8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGQ9Ik0yODAuMjcyMSwtNjAuMjg1NEMyNzkuNDQ1OSwtODEuMDM4MSAyNzguMDg4NCwtMTE1LjEzODkgMjc3LjEyNTYsLTEzOS4zMjU3Ii8+Cjxwb2x5Z29uIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSIyNzMuNjI3NywtMTM5LjIwNTMgMjc2LjcyNywtMTQ5LjMzNjcgMjgwLjYyMjEsLTEzOS40ODM5IDI3My42Mjc3LC0xMzkuMjA1MyIvPgo8L2c+CjwhLS0gYmNyIC0tPgo8ZyBpZD0iYmNyIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5iY3I8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiNmZmZmZmYiIHBvaW50cz0iNTgwLjg2NzQsLTYwIDQ3My4xMzI2LC02MCA0NzMuMTMyNiwtMjQgNTgwLjg2NzQsLTI0IDU4MC44Njc0LC02MCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI1MjciIHk9Ii0zNy44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPnJlbW90ZV9pbmRleDogMDwvdGV4dD4KPC9nPgo8IS0tIGJjciYjNDU7Jmd0O2NibCAtLT4KPGcgaWQ9ImVkZ2U0IiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5iY3ItJmd0O2NibDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgZD0iTTUyOC42MDE0LC02MC4yODU0QzUzMC40MTg5LC04MS4wMzgxIDUzMy40MDU1LC0xMTUuMTM4OSA1MzUuNTIzNywtMTM5LjMyNTciLz4KPHBvbHlnb24gZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjUzMi4wNDEzLC0xMzkuNjgwMiA1MzYuNDAwNSwtMTQ5LjMzNjcgNTM5LjAxNDYsLTEzOS4wNjk0IDUzMi4wNDEzLC0xMzkuNjgwMiIvPgo8L2c+CjwvZz4KPC9zdmc+"></p>
<p>Another interesting note on <code>wireguard</code>, it obfuscates the
indices used in its packets by randomizing them into a 24 bit address
space, hiding the total number of peers using the system. Since security
is absolutely not a concern for us, we keep it simple and attempt no
such obfuscation.</p>
<p>Alright, now we can state our first problem: design a handshake
protocol to establish <code>remote_index</code> values satisfying:</p>
<ul>
<li><code>A.peer(name=B).local_index == B.peer(name=A).remote_index</code></li>
<li><code>A.peer(name=B).remote_index == B.peer(name=A).local_index</code></li>
</ul>
<p>However, we will not tackle it right away, instead let’s explore the
problem space a little bit more and talk about:</p>
</div>
<div id="the-dual-purposes-of-allowedips" class="section level3">
<h3>The Dual Purposes of <code>AllowedIPs</code></h3>
<p>As we have learned, the heart of a VPN application is handling
communications in two directions: <code>tun -&gt; udp</code>and
<code>udp -&gt; tun</code>. Consider the first direction in a multi-peer
setting, when an IP packet is extracted from the <code>tun</code>
interface, we face a decision: to which <code>Peer</code> should this
packet be sent? The answer lies in inspecting the packet’s <a href="https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Packet_structure">IP
header</a>, specifically its destination address.</p>
<p>This is the first purpose of <code>AllowedIPs</code>. This is a new
concept to us, but an essential configuration component in
<code>wireguard</code>. <code>AllowedIPs</code> is a list of CIDR
notations associated with each peer, defining a range of IP addresses
that the peer is responsible for. The routing logic involves checking
the packet’s destination address (<code>dst</code>) against the
<code>AllowedIPs</code> of each <code>Peer</code>. The packet is sent to
the <code>Peer</code> whose <code>AllowedIPs</code> range includes
<code>dst</code>. In cases where multiple peers match, the one with the
longest prefix match is selected.</p>
<p>Conversely, for incoming UDP datagrams, after decapsulation, we
obtain an IP packet with a known source address (<code>src</code>).
Given the connected <code>Peer</code> from which this packet originates,
we check if <code>src</code> falls within that peer’s
<code>AllowedIPs</code>. If it does, the packet is forwarded to the
<code>tun</code> interface; if not, it’s dropped. This step ensures that
only packets from valid sources are processed and forwarded.</p>
<p>In our code base, the <code>AllowedIPs</code> is represented by the
following type (interface only, implementation omitted):</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">AllowedIps</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span>

<span class="p">}</span><span class="w"></span>



<span class="k">impl</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AllowedIps</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>



<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="nc">IpAddr</span><span class="p">,</span><span class="w"> </span><span class="n">cidr</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="nc">D</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>



<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">key</span>: <span class="nc">IpAddr</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>



<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">D</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>



<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Iter</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>



<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Well, a confession: I straight up stole it from <a href="https://github.com/cloudflare/boringtun/blob/f672bb6c1e1e371240a8d151f15854687eb740bb/boringtun/src/device/allowed_ips.rs"><code>boringtun</code></a>,
which uses an efficient trie-based lookup table from the crate <a href="https://crates.io/crates/ip_network_table"><code>ip_network_table</code></a>.</p>
<p>This structure and its methods provide the necessary functionality to
manage the <code>AllowedIPs</code> configurations for each peer. It
includes operations for inserting new ranges, querying for a specific IP
address, and iterating over all entries. The generic parameter
<code>D</code> allows for associating additional data with each CIDR
range, providing flexibility in how <code>AllowedIPs</code> is utilized
in the broader context of the application.</p>
<p>To summarize, <code>AllowedIPs</code> in our VPN application achieves
two key objectives:</p>
<ol style="list-style-type: decimal">
<li><strong>Peer Selection for Outgoing Packets</strong>: Determines
which peer an outgoing IP packet should be routed to based on its
destination address.</li>
<li><strong>Source Address Filtering for Incoming Packets</strong>:
Ensures that incoming packets are from an allowed source before
forwarding them to the <code>tun</code> interface.</li>
</ol>
<p>And we are ready to state our second problem: <code>Peer</code>
selection for IO events on both <code>tun</code> and
<code>UdpSocket</code>s, which we will address first in the next
sub-section.</p>
</div>
<div id="peer-selection" class="section level3">
<h3><code>Peer</code> Selection</h3>
<p>For outgoing traffic, we make the following changes to our
<code>Device</code> type:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">peers_by_ip</span>: <span class="nc">AllowedIps</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Peer</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In <code>handle_tun</code>:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">handle_tun</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">src_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">thread_data</span><span class="p">.</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">iface</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">src_buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">etherparse</span>::<span class="n">Ipv4HeaderSlice</span>::<span class="n">from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">iph</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iph</span><span class="p">.</span><span class="n">source_addr</span><span class="p">();</span><span class="w"></span>

<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iph</span><span class="p">.</span><span class="n">destination_addr</span><span class="p">();</span><span class="w"></span>

<span class="w">                </span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">peers_by_ip</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;use peer&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>For incoming traffic,</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Device</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">peers_by_index</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Peer</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>…and make changes to <code>handle_udp</code>:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">handle_udp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">sock</span>: <span class="kp">&amp;</span><span class="nc">UdpSocket</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ThreadData</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">src_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">thread_data</span><span class="p">.</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">((</span><span class="n">nbytes</span><span class="p">,</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">peer_addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer_addr</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Ipv4 only</span>

<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Packet</span>::<span class="n">parse_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src_buf</span><span class="p">[</span><span class="o">..</span><span class="n">nbytes</span><span class="p">])</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">peer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="c1">// ... other variants of our new protocol</span>

<span class="w">            </span><span class="n">Packet</span>::<span class="n">Data</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">peers_by_index</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender_idx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">peer</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;use peer&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>OK, now it is time to dive into the proposed <code>Packet</code>
<code>enum</code> and design a new VPN protocol that addresses both of
our problems outline in previous sub-sections.</p>
</div>
</div>




</div>



<!-- tabsets -->



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->


</body>
</html>
