<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="pandoc">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Yiran Sheng">

<meta name="date" content="2016-03-09">

<title>this: caveat in javaScript’s scoping rule</title>


<meta name="viewport" content="width=device-width, initial-scale=1">














<link href="less/main.css" rel="stylesheet" tyle="text/css"><link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,700|Roboto+Mono:400,700&subset=latin,latin-ext" rel="stylesheet" type="text/css"></head>

<body>




<div class="container-fluid main-container">

<!-- tabsets -->



<!-- code folding -->






<div class="fluid-row" id="header">


<h1 class="title">this: caveat in javaScript’s scoping rule</h1>
<h4 class="author"><em>Yiran Sheng</em></h4>
<h4 class="date"><em>03/09/2016</em></h4>

</div>


<div id="lexical-vs.dynamic-scoping" class="section level2">
<h2>Lexical vs. Dynamic Scoping</h2>
<p>The use of local variables — of variable names with limited scope, that only exist within a specific function — helps avoid the risk of a name collision between two identically named variables. However, there are two very different approaches to answering this question: What does it mean to be “within” a function?</p>
<p>In lexical scoping (or lexical scope; also called static scoping or static scope), if a variable name’s scope is a certain function, then its scope is the program text of the function definition: within that text, the variable name exists, and is bound to the variable’s value, but outside that text, the variable name does not exist. By contrast, in dynamic scoping (or dynamic scope), if a variable name’s scope is a certain function, then its scope is the time-period during which the function is executing: while the function is running, the variable name exists, and is bound to its variable, but after the function returns, the variable name does not exist. This means that if function f invokes a separately defined function g, then under lexical scoping, function g does not have access to f’s local variables (assuming the text of g is not inside the text of f), while under dynamic scoping, function g does have access to f’s local variables (since g is invoked during the invocation of f).</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;apple&#39;</span><span class="p">;</span>

  

  <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">;</span>

    <span class="nx">logFrom</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">);</span>

  <span class="p">}</span>

  

  <span class="kd">function</span> <span class="nx">logFrom</span><span class="p">(</span><span class="nx">calledFrom</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// variable x used here</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Callsite: &#39;</span><span class="p">,</span> <span class="nx">calledFrom</span><span class="p">,</span> <span class="s1">&#39; x is: &#39;</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="nx">logFrom</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">);</span>

  <span class="nx">inner</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
<p>JavaScript, being lexically scoped, outputs the following:</p>
<pre><code>Callsite:  main  x is:  apple
Callsite:  inner  x is:  apple</code></pre>
<p>For a dynamically scoped language, the output will be:</p>
<pre><code>Callsite:  main  x is:  apple
Callsite:  inner  x is:  orange</code></pre>
<p>So, what exactly does this program print? It depends on the scoping rules. If the language of this program is one that uses lexical scoping, then g prints and modifies the global variable x (because g is defined outside f), so the program prints 1 and then 2. By contrast, if this language uses dynamic scoping, then g prints and modifies f’s local variable x (because g is called from within f), so the program prints 3 and then 1. (As it happens, the language of the program is Bash, which uses dynamic scoping; so the program prints 3 and then 1.)</p>
</div>
<div id="javascript-uses-lexical-scoping-mostly" class="section level2">
<h2>JavaScript Uses Lexical Scoping … Mostly</h2>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">logArgs</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Context: &#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Arguments: &#39;</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>

<span class="p">}</span>



<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>

  <span class="nx">log</span> <span class="o">:</span> <span class="nx">logArgs</span>

<span class="p">};</span>



<span class="c1">// this shows the binding of this can only be determined </span>

<span class="c1">// at runtime</span>



<span class="k">if</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.66</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">logArgs</span><span class="p">();</span>  <span class="c1">// Context will be window/global object</span>

<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.33</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">logArgs</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s1">&#39;This&#39;</span><span class="p">)</span>  <span class="c1">// Context will be string &#39;This&#39;</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

  <span class="nx">obj</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>  <span class="c1">// Context will be obj</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

<span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;change&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

  <span class="nx">self</span><span class="p">.</span><span class="nx">method</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>

<span class="p">});</span>
</pre></div>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

<span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="nx">that</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">();</span>

<span class="p">});</span>
</pre></div>
<p>The trick here is to assign <code>this</code> to a variable (common names: <code>that</code>, <code>self</code>, <code>context</code>), eliminate the usage of it inside function bodies, and rely on lexical scoping rule to find the binding to the correct value. Some fun stats using github search:</p>
<ul>
<li><p>8 million <code>var self = this;</code> (<a href="https://github.com/search?l=javascript&amp;q=var+self+%3D+this%3B&amp;type=Code&amp;utf8=%E2%9C%93">Link</a>)</p></li>
<li><p>61 million <code>var that = this;</code> (<a href="https://github.com/search?utf8=%E2%9C%93&amp;q=var+that+%3D+this%3B&amp;type=Code&amp;ref=searchresults">Link</a>)</p></li>
</ul>
<div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;change&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</pre></div>
</div>
<div id="es6-introducing-arrow-functions" class="section level2">
<h2>ES6: Introducing Arrow Functions</h2>
<p>Syntax-wise, ES6 introduces two new way of defining a function, both removed the usage of the <code>function</code> keyword:</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

  <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// ...</span>

  <span class="p">}</span>

<span class="p">}</span>



<span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

   <span class="c1">// ...</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">oldWay</span><span class="p">()</span> <span class="p">{</span>

  <span class="kd">let</span> <span class="nx">newWay</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// this may still surprise you</span>

  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

  <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>

  <span class="p">}</span>

<span class="p">}</span>

<span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">func</span><span class="p">;</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</pre></div>
</div>




</div>



<!-- dynamically load mathjax for compatibility with self-contained -->


</body>
</html>

