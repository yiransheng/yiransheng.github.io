---
title: "Callback and CPS in JavaScript"
author: "Yiran Sheng"
date: "03/04/2016"
output:
  html_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
library(knitr)
knit_engines$set(javascript=function(options){engine_output(options, options$code, '')})
names(knit_engines$get())
```


## Random Introduction

Continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation ([Wikipedia](https://en.wikipedia.org/wiki/Continuation-passing_style)). In this article, I will take a stab at establishing a somewhat solid basis of CPS in javaScript, specifically with a monadic interface. Most of the work here are more or less direct translation of Haskell code found in this tutorial: 

**[Haskell/Continuation passing style](https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style)**

Before moving on, I'd like provide a few short paragraphs of recap on some articles on this topic that helped me understand both the motivation and inner workings of CPS.

**[②ality: Asynchronous programming and continuation-passing style in JavaScript](http://www.2ality.com/2012/06/continuation-passing-style.html)**

**[What color is your function?](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)**

> ... If you’re programming in JavaScript on Node.js, everytime you define a function that “returns” a value by invoking a callback, you just made a red function. 

This article [Spoiler Alert] illustrates the fundamental difficulties in composing direct style (normal) functions and callback taking functions (typically async in nature). Modern day javaScript has plenty of tools in dealing with the issue here: `Promise`, `async/await`, `generators`, `Observables/FRP`, golang style `CSP` and more. However, almost all of these newer constructs aim to eliminate the heavy usage of callbacks and try to turn callback hell into some innocent/synchronous looking code - either in imperative (eg. CSP) or functional style (eg. FRP). 

Callback hell is an integral part of javaScript's notoriety However, callback hell, or rather multiple level nested functions are _not_ necessarily "considered harmful" in functional programming. For instance, consider some simple monadic comprehension code in Haskell: 

```{haskell, engine.path='ghc'}
triplets = do 
    x <- xs
    y <- ys
    z <- zs
    return (x,y,z)
```

which desugars to:

```{haskell, engine.path='ghc'}
let triplets = xs >>= \x ->
                         ys >>= \y ->
                                   zs >>= \z ->
                                             return (x,y,z)
```

This certainly looks like callback hell. In fact it is very common in Haskell to have functions deeply nested, and refer to bindings(variables) a few level of lexical scopes above. Obviously, there's no `do` notation in javaScript to make nested functions less ugly looking, yet this leads me to thinking the nesting part in callback hell maybe is not that bad after all. I will expand a little bit more on this thought towards the end.

**[The Mother of all Monads](https://www.schoolofhaskell.com/user/dpiponi/the-mother-of-all-monads)**

> There are some interesting consequences of this beyond Haskell. Many languages with support for continuations should be extensible to support monads. In particular, if there is an elegant notation for continuations, there should be one for monads too.

It is refreshing to know composing CPS functions can be done implicitly in a monadic interface (`Cont` monad in Haskell), the article above proves the reverse is also true: first-class continuation can be used to represent and express monads. There's no convinient way to define and use monad in javaScript, nor a concept of first-class continuation. However, callback taking functions are everywhere in javaScript both client and server side, therefore, it might interests us to settle on a specific implementation of CPS and build monads on top of it. 

At this point, hopefully my motivation for this excersice becomes more clear. The rest of article will be deticated to too tasks:

1. Introduce and formalize a way to create "poor man's monad" and use it to build `Cont` monad, as well as `call/cc` function

2. Implement a somewhat diciplined way of CPS, and use it to build generalized monads

## Continuation vs. Callback

Broadly speaking, continuation is a special case of callback. If we have a function which takes a callback, say it's an api from some library, there's no knowing when, with what arguments, and how many times our callback gets invoked (or it gets invoked at all). To contrast with CPS, consider these two paragraphs from the [Wikipedia page](https://en.wikipedia.org/wiki/Continuation-passing_style) of continuation passing style:

> A function written in continuation-passing style takes an extra argument: an explicit "continuation" i.e. a function of one argument. When the CPS function has computed its result value, it "returns" it by calling the continuation function with this value as the argument. 

> Note that in CPS, there is no implicit continuation—every call is a tail call. There is no "magic" here, as the continuation is simply explicitly passed. 

This implies a CPS function will typically call the continuation/callback function:

* only once
* at its tail position (place where its direct style counter-part will simply return)

Another distinction is whether or not a CPS function should return the result of calling continuation. This can be illustrated with the most trival CPS function `id`.

```{javascript, eval=F}
// direct style 
function id(x) {
  return x;
}

// cps implementation 1
function id_cps1(x, k) {
  k(x);
}

// cps implementation 2
function id_cps2(s, k) {
  return k(x);
}
```

Haskell's `Control.Monad.Cont` opts to implementation continuations similar to `id_cps2` above. This makes sense. Original concept of a continuation in Scheme is defined as a procedure instead of pure functions. In other words, a continuation can have side effects such as the procedure `print`. Haskell models continuation as pure functions, which means our `id_cps1` will essentially become:

```{haskell, eval=F}
let idCps1 x k = ()
```

Certainly not very useful.

However, this lesson does not carry over to javaScript. In almost all cases, a function/api is designed to take a callback because it is asyncous, and the callback is simply invoked some time in the future and its results discarded. In other words, almost all the callback based functions in javaScript cannot be modeled using Haskell's flavor of CPS; otherwise, we would've been able to do things like:

```{javascript, eval=F}
let id = x => x;
let contents = fs.readFile('file.txt', id);
// in reality contents evaluates to undefined
```

In which case, practitioners probably won't even bother, and just use: 

```{javascript}
let contents = fs.readFileSync('file.txt');
```

It seems CPS cannot really help us with aync tasks, all it's capable of is turning straight-forward syncous code int



## Poor man's Monad

```{javascript, eval=F, result='asis'}
class MyMonad {
  constructor() {
    
  }
  /*
   * @param f - {function} a -> MyMonad b
   */
  bind(f) {
  
  }
  map(f) {
    return this.bind(x => MyMonad.unit( f(x) ));
  }
  apply(m) {
    return this.bind(f => m.bind(x => {
      return MyMonad.unit(f(x));
    }));
  }
}
// :: a -> MyMonad a
MyMonad.unit = function() {

}
```

## Cont. Monad in js

```{javascript, eval=F, result='asis'}
function Cont (f, async) {
  this._func = f;
  this._async = !!async;
  if(async) {
    this.promise = Promise.resolve(true);
  }
}
Cont.prototype = {
  runCont : function(k) {
    return this._async ? this.runContAsync_(k) : this.runContSync_(k);
  },
  runContSync_ : function(k) {
    var f = this._func;
    return f(k);
  },
  runContAsync_ : function(k) {
    var f = this._func;
    var n = 0;
    return new Promise((resolve, reject) => {
      f(function(err, result) {
        if(!err) {
          resolve(k(null, result));
        } else {
          reject(k(err, null)); 
        }
      });
    });
  },
  map : function(f) {
    return this.bind(function(x) {
      return Cont.unit(f(x));
    });
  },
  bind : function(f) {
    return new Cont(k => {
      return this.runCont((err, result) => {
        var newCont;
        if(err) {
          return this._async ? Promise.reject(err) : k(err, null);
        } else {
          newCont = f(result);
          newCont._async = this._async ? true : newCont.async;
          return newCont.runCont(k);
        }
      });
    }, this._async);
  },
  filter : function(predicate) {
    return this.bind(function(x) {
      return predicate(x) ? Cont.unit(x) : Cont.empty;
    }); 
  }
};

```

## call/cc 

## async/await, and _do_ notation 

```{r, echo=FALSE, results='asis', message=FALSE}
x <- rnorm(1000)
y <- 1 + x * 2 + rnorm(1000, 0, seq(1, 1000) * 0.01)
fit <- lm(y~x)
library(stargazer)
stargazer(fit, type='html')
```

## next